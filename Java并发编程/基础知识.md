## Java中的线程安全是指什么

线程安全是指多个线程访问某一共享资源时，能够保诉一致件和下确件，即无论线程如何交替执行，程序都能够产生预期的结果，目不会出现数据竞争或内存冲突、在 Java 中，线程安全的
实现通常依赖于同步机制和线程隔离技术。

## 常见的线程安全的方法

- 同步锁:通过synchronized关键字或ReentrantLock 实现对共享资源的同步控制。
- 原子操作类:Java 提供的 AtomicInteger、AtomicReference 等类确保多线程环境下的原子性操作。
- 线程安全容器:如ConcurrentHashMap、 CopyOnWriteArrayList等，避免手动加锁
- 局部变量:线程内独立的局部变量天然是线程安全的，因为每个线程都有自己的栈空间(线程隔离)
- ThreadLocal:类似于同部变量，属于线程本地资源，通过线程隔离保证了线程安全。

## 线程安全

### **1. 线程安全的核心问题**

多线程环境下可能出现的问题主要源于以下几点：



- **竞态条件**（Race Condition）：多个线程同时访问和修改共享资源，导致执行结果依赖于线程执行的时序。
- **内存可见性**（Visibility）：一个线程对共享变量的修改可能无法及时被其他线程看到。
- **指令重排序**（Reordering）：编译器或处理器为了优化性能，可能会对指令执行顺序进行重排，影响多线程环境下的正确性。

### **2. Java 中实现线程安全的主要方式**

#### **2.1 同步机制**

- synchronized 关键字

  ：通过获取对象锁（监视器锁）来保证同一时刻只有一个线程执行同步代码块。

  java











  ```java
  public synchronized void increment() {
      count++; // 同一时刻只有一个线程能执行此方法
  }
  ```





![img](data:image/png;base64,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)

- ReentrantLock

  ：显式锁，功能更灵活（如可中断锁、公平锁）。

  java











  ```java
  private final Lock lock = new ReentrantLock();
  public void increment() {
      lock.lock();
      try {
          count++;
      } finally {
          lock.unlock();
      }
  }
  ```

#### **2.2 原子操作**

使用`java.util.concurrent.atomic`包中的原子类（如`AtomicInteger`、`AtomicReference`），基于 CAS（Compare-and-Swap）实现无锁线程安全。



java











```java
private AtomicInteger count = new AtomicInteger(0);
public void increment() {
    count.incrementAndGet(); // 原子操作，无需加锁
}
```

#### **2.3 不可变对象**

不可变对象（如`String`、`Integer`）天生线程安全，因为状态不可修改。



java











```java
public final class ImmutableValue {
    private final int value;
    public ImmutableValue(int value) {
        this.value = value;
    }
    public int getValue() {
        return value;
    }
}
```

#### **2.4 线程封闭**

将对象限制在单线程中使用，避免共享（如`ThreadLocal`、局部变量）。



java











```java
private ThreadLocal<Integer> threadLocal = ThreadLocal.withInitial(() -> 0);
public void increment() {
    threadLocal.set(threadLocal.get() + 1); // 每个线程独立维护自己的值
}
```

#### **2.5 并发容器**

使用线程安全的容器（如`ConcurrentHashMap`、`CopyOnWriteArrayList`）替代非线程安全的容器（如`HashMap`、`ArrayList`）。



java











```java
private Map<String, Integer> map = new ConcurrentHashMap<>();
public void put(String key, int value) {
    map.put(key, value); // 线程安全的put操作
}
```

### **3. 线程安全的分类**

根据线程安全的程度，Java 中的类可分为以下几类：



- **不可变类**（如`String`、`BigInteger`）：无需同步，永远线程安全。
- **无条件线程安全**（如`ConcurrentHashMap`、`AtomicInteger`）：方法本身实现了同步，调用时无需额外同步。
- **有条件线程安全**（如`Collections.synchronizedList`）：某些操作需要外部同步（如迭代器需要手动加锁）。
- **非线程安全**（如`HashMap`、`ArrayList`）：多线程环境下必须通过外部手段保证线程安全。

### **4. 示例对比**

#### **非线程安全示例（HashMap）**

java











```java
Map<String, Integer> map = new HashMap<>(); // 非线程安全
// 多线程环境下可能出现竞态条件
new Thread(() -> map.put("key", 1)).start();
new Thread(() -> map.put("key", 2)).start();
```

#### **线程安全示例（ConcurrentHashMap）**

java











```java
Map<String, Integer> map = new ConcurrentHashMap<>(); // 线程安全
// 多线程环境下无需额外同步
new Thread(() -> map.put("key", 1)).start();
new Thread(() -> map.put("key", 2)).start();
```

### **5. 线程安全的注意事项**

- **过度同步的风险**：同步会带来性能开销，甚至可能导致死锁。
- **复合操作的原子性**：即使单个方法是线程安全的，多个操作的组合也可能不是原子的（如`if (map.containsKey(key)) { map.put(key, value); }`）。
- **可见性与有序性**：仅靠`synchronized`或`Lock`无法完全解决可见性问题，需要配合`volatile`关键字。

### **总结**

Java 中的线程安全是通过各种机制（同步、原子操作、不可变对象等）确保多线程环境下共享资源的正确性。选择合适的线程安全策略需要根据具体场景权衡性能和安全性，避免过度同步或同步不足。理解线程安全的本质是编写高效、可靠并发程序的关键。


## 协程

### **1. 协程的核心概念**

- **轻量级**：协程的创建和销毁成本远低于线程，通常只需 KB 级内存。
- **非抢占式调度**：协程主动让出执行权（而非被操作系统强制暂停），因此称为**协作式多任务**。
- **挂起与恢复**：协程可以在执行过程中暂停（挂起），保存当前状态，稍后从暂停处继续执行（恢复）。
- **线程绑定**：多个协程可以在同一个线程上运行，减少线程切换开销。

### **2. Java 中的协程实现**

Java 传统上依赖`Thread`和`ExecutorService`实现并发，这些都是**抢占式线程**。但近年来，随着项目 Loom 的推进，Java 开始支持原生协程（称为**虚拟线程**）。

#### **2.1 虚拟线程（Virtual Threads，JDK 19+）**

虚拟线程是 Java 对协程的原生支持，作为项目 Loom 的一部分引入，从 JDK 19 开始作为预览特性。



**特点**：



- **由 JVM 管理**：虚拟线程依附于普通线程（载体线程）执行，JVM 负责调度。
- **与平台线程解耦**：一个载体线程可以运行多个虚拟线程，避免创建大量操作系统线程。
- **语法兼容**：使用与普通线程相同的 API（`Thread`、`Runnable`），无需额外学习。

### **3. 协程的应用场景**

- **高并发 IO 密集型任务**：如 Web 服务器、数据库连接池，协程可以在等待 IO 时让出执行权，提高吞吐量。
- **事件驱动系统**：处理大量异步事件，避免回调地狱。
- **微服务通信**：在服务间调用时减少线程阻塞。

### **4. 协程与线程的对比**

| **特性**       | **线程（Thread）**       | **协程（Coroutine）**          |
| -------------- | ------------------------ | ------------------------------ |
| **调度方式**   | 抢占式（由操作系统调度） | 协作式（由应用程序调度）       |
| **内存占用**   | 较大（通常 1MB+）        | 极小（通常 KB 级）             |
| **创建成本**   | 高                       | 低                             |
| **上下文切换** | 开销大（涉及内核态）     | 开销小（用户态）               |
| **适用场景**   | CPU 密集型任务           | IO 密集型任务                  |
| **阻塞影响**   | 阻塞会导致整个线程挂起   | 仅当前协程挂起，不影响其他协程 |

### **5. 协程的优缺点**

**优点**：



- **资源高效**：支持数百万级并发，内存占用少。
- **简化异步编程**：避免回调地狱，代码更接近同步写法。
- **提高吞吐量**：在 IO 密集型场景下显著提升性能。



**缺点**：



- **调试困难**：协程的执行顺序可能不直观，调试工具不完善。
- **不适合 CPU 密集型任务**：协程切换仍有开销，无法替代多线程并行。
- **兼容性问题**：第三方库可能需要适配虚拟线程。

![img.png](img.png)

## 线程的生命周期
在 Java 语言里线程共有六种状态，分别是：

1. NEW 初始化状态
2. RUNNABLE 可运行 / 运行状态
3. BLOCKED 阻塞状态
4. WAITING 无时限等待
5. TIMED_WAITING 有时限等待
6. TERMINATED 终止状态

![img_2.png](img_2.png)

那么有哪些情形会导致线程从 RUNNABLE 状态切换到这三种状态呢？

1. RUNNABLE 与 BLOCKED 的状态切换

   只有一种场景会触发这种切换，就是线程等待 synchronized 的隐式锁。synchronized 修饰的方法、代码块同一时刻只允许一个线程执行，其他线程只能等待，这种情况下，等待的线程就会从 RUNNABLE 转换为 BLOCKED 状态。而当等待的线程获得 synchronized 隐式锁时，就又会从 BLOCKED 转换为 RUNNABLE 状态。

   如果线程调用阻塞式 API 时，是否会转换为 BLOCKED 状态呢？在操作系统层面，线程是会转换到休眠状态的，但是在 JVM 层面，Java 线程的状态不会发生变化，也就是说 Java 线程的状态会依然保持 RUNNABLE 状态。JVM 层面并不关心操作系统调度相关的状态，因为在 JVM 看来，等待 CPU 使用权（操作系统层面此时处于可执行状态）与等待 I/O（操作系统层面此时处于休眠状态）没有区别，都在等待某个资源，所以都归入了 RUNNABLE 状态。

   而我们平时所谓的 Java 在调用阻塞式 API 时，线程会阻塞，指的是操作系统线程的状态，并不是 Java 线程的状态。

2. RUNNABLE 与 WAITING 的状态转换

   总的来说，有三种场景会触发这种转换。

   第一种场景，获得 synchronized 隐式锁的过程，调用无参数的 Object.wait() 方法。

   第二种场景，调用无参数的 Thread.join() 方法。其中的 join() 是一种线程同步方法。例如有一个线程对象 ThreadA，当调用 ThreadA.join() 的时候，执行这条语句的线程会等待 ThreadA 执行完，而等待中的这个线程，其状态会从 RUNNABLE 转换到 WAITING。当线程 ThreadA 执行完，原来等待它的线程又会从 WAITING 状态转换到 RUNNABLE。

   第三章场景，调用 LockSupport.park() 方法，当前线程会阻塞，线程的状态会从 RUNNABLE 转换到 WAITING。调用 LockSupport.unpark(Thread thread) 可唤醒目标线程，目标线程的状态又会从 WAITING 状态转换到 RUNNABLE。

3. RUNNABLE 与 TIMED_WAITING 的状态转换

   有五种场景会触发这种转换。

   第一种，调用带超时参数的 Thread.sleep(long millis) 方法；

   第二种，获得 synchronized 隐式锁的线程，调用带超时参数的 Object.wait(long millis) 方法；

   第三种，调用带超时参数的 Thread.join(long millis) 方法；

   第四种，调用带超时参数的 LockSupport.parkNanos(Object blocker, long deadline) 方法；

   第五种，调用带超时参数的 LockSupport.parkUntil(long deadline) 方法；

   这里 TIMED_WAITING 和 WAITING 状态的区别，仅仅是触发条件多了超时参数。

4. 从 NEW 到 RUNNABLE 状态

   Java 刚创建出来的 Thread 对象就是 NEW 状态，而创建 Thread 对象主要有两种方法。一种是继承 Thread 对象，另一种是实现 Runnable 接口。NEW 状态的线程，不会被操作系统调度，因此不会执行。Java 线程要执行，就必须转换为 RUNNABLE 状态。从 NEW 状态转换到 RUNNABLE 状态很简单，只要调用线程对象的 start() 方法即可。

5. 从 RUNNABLE 到 TERMINATED 状态

   线程执行完 run() 方法后，会自动转换到 TERMINATED 状态，当然如果执行 run() 方法的时候抛出异常，也会导致线程终止。有时候我们需要强制中断 run() 方法的执行，例如 run() 方法访问一个很慢的网络，我们等不下去了，想要终止怎么办？Java 的 Thread 类倒是提供了 stop() 方法，不过已经被标记为 @Deprecated，所以不建议使用了，正确的姿势其实是调用 interrupt() 方法。

那 stop() 和 interrupt() 方法的主要区别是什么呢？

stop() 方法会真的杀死线程，不给线程喘息的机会，如果线程持有 synchronized 隐式锁，也不会释放，那其他线程就再也没机会获得 synchronized 隐式锁，这实在是太危险了。所以该方法就不建议使用了，类似的方法还有 suspend() 和 resume() 方法。

而 interrupt() 方法就温柔多了，interrupt() 方法仅仅是通知线程，线程有机会执行一些后续操作，同时也可以无视这个通知。被 interrupt 的线程，是怎么收到通知的呢？一种是异常，另一种是主动检测。

当线程 A 处于 WAITING、TIMED_WAITING 状态时，如果其它线程调用 A 的 interrupt() 方法，会使线程 A 返回到 RUNNABLE 状态，同时线程 A 的代码会触发 InterruptedException 异常。上面我们提到转换到 WAITING、TIMED_WAITING 状态的触发条件，都是调用了类似 wait()、join()、sleep() 这样的方法，这些方法都会 throws InterruptedException 这个异常。这个异常的触发条件就是：其它线程调用了该线程的 interrupt() 方法。

当线程 A 处于 RUNNABLE 状态时，并且阻塞在 java.nio.channels.InterruptibleChannel 上时，如果其它线程调用线程 A 的 interrupt() 方法，线程 A 会触发 java.nio.channels.ClosedByInterruptException 这个异常；而阻塞在 java.nio.channels.Selector 上时，如果其它线程调用线程 A 的 interrupt() 方法，线程 A 的 java.nio.channels.Selector 会立即返回。

上面这两种情况属于被中断的线程通过异常的方式获得了通知。还有一种是主动监测，如果线程处于 RUNNABLE 状态，并且没有阻塞在某个 I/O 操作上，例如中断计算圆周率的线程 A，这时就得依赖线程 A 主动检测中断状态了。如果其它线程调用线程 A 的 interrupt() 方法，那么线程 A 可以通过 isInterrupted() 方法，检测是不是自己被中断了。

![img_1.png](img_1.png)


## Java中线程间如何通信

### **1. 共享内存（隐式通信）**

通过共享变量实现线程间的数据交换，需配合同步机制（如`synchronized`、`volatile`）保证可见性和原子性。

#### **1.1 `volatile`关键字**

保证变量的可见性，即一个线程修改后，其他线程能立即看到最新值。



java











```java
public class VolatileExample {
    private static volatile boolean flag = false;

    public static void main(String[] args) {
        // 线程1：修改flag
        new Thread(() -> {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            flag = true;
            System.out.println("线程1：flag已设为true");
        }).start();

        // 线程2：等待flag
        new Thread(() -> {
            while (!flag) {
                // 等待flag变为true
            }
            System.out.println("线程2：检测到flag为true");
        }).start();
    }
}
```

#### **1.2 `synchronized`同步块**

通过锁保证代码块的原子性和可见性。



java











```java
public class SynchronizedExample {
    private final Object lock = new Object();
    private boolean ready = false;

    public void producer() {
        synchronized (lock) {
            // 生产数据
            ready = true;
            lock.notifyAll(); // 唤醒等待的线程
        }
    }

    public void consumer() {
        synchronized (lock) {
            while (!ready) {
                try {
                    lock.wait(); // 等待数据准备好
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
            // 消费数据
        }
    }
}
```

### **2. 等待 / 通知机制（显式通信）**

通过`Object`类的`wait()`、`notify()`、`notifyAll()`方法实现线程间的协作。

#### **2.1 `wait()`与`notify()`**

- **`wait()`**：使当前线程进入等待状态，释放对象锁。
- **`notify()`**：唤醒在此对象监视器上等待的单个线程。
- **`notifyAll()`**：唤醒在此对象监视器上等待的所有线程。



**示例：生产者 - 消费者模型**



java











```java
public class ProducerConsumer {
    private final Queue<Integer> queue = new LinkedList<>();
    private final int CAPACITY = 5;

    public void produce() throws InterruptedException {
        synchronized (this) {
            while (queue.size() == CAPACITY) {
                wait(); // 队列满时等待
            }
            int item = new Random().nextInt(100);
            queue.add(item);
            System.out.println("生产者：生产了 " + item);
            notifyAll(); // 通知消费者
        }
    }

    public void consume() throws InterruptedException {
        synchronized (this) {
            while (queue.isEmpty()) {
                wait(); // 队列空时等待
            }
            int item = queue.poll();
            System.out.println("消费者：消费了 " + item);
            notifyAll(); // 通知生产者
        }
    }
}
```

### **3. 显式锁与条件变量（`Lock`与`Condition`）**

`ReentrantLock`和`Condition`提供了比`synchronized`更灵活的等待 / 通知机制。



**示例：**



java











```java
public class ConditionExample {
    private final Lock lock = new ReentrantLock();
    private final Condition condition = lock.newCondition();
    private boolean ready = false;

    public void producer() throws InterruptedException {
        lock.lock();
        try {
            while (ready) {
                condition.await(); // 等待消费者处理
            }
            // 生产数据
            ready = true;
            condition.signalAll(); // 通知消费者
        } finally {
            lock.unlock();
        }
    }

    public void consumer() throws InterruptedException {
        lock.lock();
        try {
            while (!ready) {
                condition.await(); // 等待生产者准备
            }
            // 消费数据
            ready = false;
            condition.signalAll(); // 通知生产者
        } finally {
            lock.unlock();
        }
    }
}
```

### **4. 阻塞队列（`BlockingQueue`）**

`java.util.concurrent`包中的阻塞队列提供线程安全的队列操作，当队列为空 / 满时会自动阻塞线程。



**示例：**



java











```java
public class BlockingQueueExample {
    private final BlockingQueue<Integer> queue = new LinkedBlockingQueue<>(10);

    public void producer() throws InterruptedException {
        while (true) {
            int item = new Random().nextInt(100);
            queue.put(item); // 队列满时自动阻塞
            System.out.println("生产者：生产了 " + item);
        }
    }

    public void consumer() throws InterruptedException {
        while (true) {
            int item = queue.take(); // 队列空时自动阻塞
            System.out.println("消费者：消费了 " + item);
        }
    }
}
```

### **5. 信号量（`Semaphore`）**

控制同时访问某个资源的线程数量，可用于实现限流或资源池。



java











```java
public class SemaphoreExample {
    private final Semaphore semaphore = new Semaphore(3); // 最多3个线程同时访问

    public void accessResource() throws InterruptedException {
        semaphore.acquire(); // 获取许可
        try {
            // 访问共享资源
            System.out.println(Thread.currentThread().getName() + " 获得许可");
            Thread.sleep(1000);
        } finally {
            semaphore.release(); // 释放许可
        }
    }
}
```

### **6. 线程池与 Future**

通过`ExecutorService`提交任务并获取`Future`结果，实现线程间的数据传递。



java











```java
public class FutureExample {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        ExecutorService executor = Executors.newSingleThreadExecutor();
        
        // 提交任务并获取Future
        Future<Integer> future = executor.submit(() -> {
            Thread.sleep(2000);
            return 42;
        });
        
        // 获取任务结果（阻塞直到完成）
        Integer result = future.get();
        System.out.println("任务结果：" + result);
        
        executor.shutdown();
    }
}
```

### **7. 管道流（`PipedInputStream`/`PipedOutputStream`）**

用于线程间的字节流通信，一个线程写入数据，另一个线程读取。



java











```java
public class PipedStreamExample {
    public static void main(String[] args) throws IOException {
        PipedOutputStream pos = new PipedOutputStream();
        PipedInputStream pis = new PipedInputStream(pos); // 连接输入输出流

        // 写入线程
        new Thread(() -> {
            try {
                pos.write("Hello, reader!".getBytes());
                pos.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }).start();

        // 读取线程
        new Thread(() -> {
            try {
                int data;
                while ((data = pis.read()) != -1) {
                    System.out.print((char) data);
                }
                pis.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }).start();
    }
}
```

### **8. 原子变量（`Atomic`系列）**

通过原子操作实现线程间的高效通信，避免锁的开销。



java











```java
public class AtomicExample {
    private static final AtomicInteger counter = new AtomicInteger(0);

    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                counter.incrementAndGet(); // 原子自增
            }
        });

        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                counter.decrementAndGet(); // 原子自减
            }
        });

        t1.start();
        t2.start();
        t1.join();
        t2.join();

        System.out.println("最终结果：" + counter.get()); // 输出0
    }
}
```


## Java中如何创建多线程

### **1. 继承`Thread`类**

**步骤**：



1. 继承`Thread`类并重写`run()`方法。
2. 创建子类实例并调用`start()`方法启动线程。



**示例**：



java











```java
public class MyThread extends Thread {
    @Override
    public void run() {
        System.out.println("线程执行中：" + Thread.currentThread().getName());
    }

    public static void main(String[] args) {
        MyThread thread = new MyThread();
        thread.start(); // 启动新线程，执行run()方法
        System.out.println("主线程执行中：" + Thread.currentThread().getName());
    }
}
```





![img](data:image/png;base64,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)

### **2. 实现`Runnable`接口**

**步骤**：



1. 实现`Runnable`接口的`run()`方法。
2. 将实现类实例作为参数传递给`Thread`构造器。
3. 调用`Thread`实例的`start()`方法。



**示例**：



java











```java
public class MyRunnable implements Runnable {
    @Override
    public void run() {
        System.out.println("线程执行中：" + Thread.currentThread().getName());
    }

    public static void main(String[] args) {
        Thread thread = new Thread(new MyRunnable());
        thread.start(); // 启动线程
        System.out.println("主线程执行中：" + Thread.currentThread().getName());
    }
}
```



**匿名内部类简化写法**：



java











```java
Thread thread = new Thread(new Runnable() {
    @Override
    public void run() {
        System.out.println("匿名内部类线程");
    }
});
thread.start();
```



**Lambda 表达式简化写法（Java 8+）**：



java











```java
Thread thread = new Thread(() -> System.out.println("Lambda线程"));
thread.start();
```

### **3. 实现`Callable`接口并结合`Future`**

**步骤**：



1. 实现`Callable`接口的`call()`方法（可返回值）。
2. 使用`FutureTask`包装`Callable`实例。
3. 将`FutureTask`作为参数传递给`Thread`构造器。
4. 调用`Thread`实例的`start()`方法。
5. 通过`FutureTask.get()`获取返回值（可能阻塞）。



**示例**：



java











```java
import java.util.concurrent.*;

public class MyCallable implements Callable<Integer> {
    @Override
    public Integer call() throws Exception {
        Thread.sleep(1000);
        return 42;
    }

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        Callable<Integer> callable = new MyCallable();
        FutureTask<Integer> futureTask = new FutureTask<>(callable);
        Thread thread = new Thread(futureTask);
        thread.start();

        Integer result = futureTask.get(); // 获取返回值（阻塞等待）
        System.out.println("线程返回值：" + result);
    }
}
```

### **4. 使用线程池（推荐）**

**步骤**：



1. 通过`Executors`工厂方法创建线程池。
2. 提交`Runnable`或`Callable`任务。
3. 关闭线程池（调用`shutdown()`）。



**示例：固定大小线程池**



java











```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ThreadPoolExample {
    public static void main(String[] args) {
        // 创建固定大小为3的线程池
        ExecutorService executor = Executors.newFixedThreadPool(3);

        // 提交任务
        for (int i = 0; i < 5; i++) {
            final int taskId = i;
            executor.submit(() -> {
                System.out.println("任务 " + taskId + " 由线程 " + Thread.currentThread().getName() + " 执行");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            });
        }

        // 关闭线程池
        executor.shutdown();
    }
}
```



**其他常见线程池**：



- **缓存线程池**：`Executors.newCachedThreadPool()`（按需创建线程，空闲线程自动回收）
- **单线程池**：`Executors.newSingleThreadExecutor()`（保证任务按顺序执行）
- **定时线程池**：`Executors.newScheduledThreadPool()`（支持定时 / 周期任务）

### **5. 使用`CompletableFuture`（Java 8+）**

**步骤**：



1. 通过`CompletableFuture.supplyAsync()`（有返回值）或`runAsync()`（无返回值）创建异步任务。
2. 链式调用`thenApply()`、`thenAccept()`等方法处理结果。



**示例**：



java











```java
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;

public class CompletableFutureExample {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        // 创建异步任务
        CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return "任务完成";
        });

        // 处理结果（异步）
        future.thenAccept(result -> System.out.println("结果：" + result));

        // 阻塞获取结果（可选）
        System.out.println(future.get());
    }
}
```

### **对比与选择建议**

| **方式**            | **优点**                   | **缺点**                   | **适用场景**           |
| ------------------- | -------------------------- | -------------------------- | ---------------------- |
| 继承`Thread`类      | 简单直接                   | 单继承限制，代码耦合度高   | 简单场景，不推荐       |
| 实现`Runnable`接口  | 避免单继承限制，代码解耦   | 无返回值，无法直接获取结果 | 简单异步任务           |
| 实现`Callable`接口  | 有返回值，可处理异常       | 代码复杂度稍高             | 需要返回值的任务       |
| 线程池              | 复用线程，减少创建开销     | 需要手动管理线程池         | 大量任务，生产环境推荐 |
| `CompletableFuture` | 支持链式异步编程，语法简洁 | 学习成本较高               | 复杂异步流程编排       |

### 为什么Callable接口需要被FutureTask包装后，再进行线程执行

首先:thread类，不接收calable实现类，而是接收runable实现类，所以我们需要把calable实现类转成runable实现类，而FutureTask具有这个功能
其次:calable实现类，是具有返回结果和异常信息的，我们需要获取这个结果或信息的时候，funturetask类提供了对应的get方法来获取。

### Java中的Threas类的start和run方法的区别


### **1. `start()`方法**

- **功能**：**启动一个新线程**，并让 JVM 调用该线程的`run()`方法。

- 特性

  ：

    - **异步执行**：调用`start()`后，原线程不会阻塞，新线程会并行执行。
    - **每个线程只能调用一次**：多次调用会抛出`IllegalThreadStateException`。
    - **线程生命周期管理**：新线程会经历`NEW → RUNNABLE → TERMINATED`状态变化。



**示例**：



java











```java
Thread t = new Thread(() -> System.out.println("新线程执行"));
t.start(); // 启动新线程，JVM自动调用run()
System.out.println("主线程继续执行");
```



**输出（顺序可能不同）**：



plaintext











```plaintext
主线程继续执行
新线程执行
```

### **2. `run()`方法**

- **功能**：**定义线程要执行的任务**，但直接调用`run()`不会启动新线程。

- 特性

  ：

    - **同步执行**：直接调用`run()`会在当前线程中执行代码，而非新线程。
    - **可重复调用**：但只是普通方法调用，不涉及线程生命周期。



**示例**：



java











```java
Thread t = new Thread(() -> System.out.println("任务执行"));
t.run(); // 直接调用run()，不会启动新线程
System.out.println("主线程继续执行");
```



**输出（顺序固定）**：



plaintext











```plaintext
任务执行
主线程继续执行
```

### **3. 核心区别对比**

| **对比项**   | **`start()`方法**                                    | **`run()`方法**                       |
| ------------ | ---------------------------------------------------- | ------------------------------------- |
| **线程创建** | 启动新线程，JVM 调用`run()`                          | 不创建新线程，在当前线程执行代码      |
| **执行方式** | 异步执行，与原线程并行                               | 同步执行，原线程需等待`run()`执行完成 |
| **调用次数** | 每个线程实例只能调用一次                             | 可重复调用，作为普通方法              |
| **线程状态** | 触发线程状态变化（`NEW → RUNNABLE`）                 | 不影响线程状态                        |
| **异常处理** | 新线程中的未捕获异常由`UncaughtExceptionHandler`处理 | 异常由当前线程处理                    |

### **4. 常见错误案例**

**错误写法**：直接调用`run()`



java











```java
public class WrongExample {
    public static void main(String[] args) {
        Thread t = new Thread(() -> {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("新线程执行");
        });
        
        t.run(); // 错误！不会启动新线程，而是在主线程执行
        System.out.println("主线程结束");
    }
}
```



**输出（顺序固定）**：



plaintext











```plaintext
// 等待1秒（因为主线程执行sleep）
新线程执行
主线程结束
```

### **5. 源码分析**

- **`start()`源码**（简化）：

  java











  ```java
  public synchronized void start() {
      if (threadStatus != 0)
          throw new IllegalThreadStateException();
      group.add(this);
      boolean started = false;
      try {
          start0(); // 本地方法，由JVM创建并启动新线程
          started = true;
      } finally {
          // ...
      }
  }
  private native void start0();
  ```

- **`run()`源码**：

  java











  ```java
  public void run() {
      if (target != null) {
          target.run(); // target是Runnable实例
      }
  }
  ```

### **6. 正确使用示例**

java











```java
public class ThreadExample {
    public static void main(String[] args) {
        // 方式1：继承Thread类并重写run()
        Thread t1 = new Thread() {
            @Override
            public void run() {
                System.out.println("t1执行");
            }
        };
        t1.start(); // 启动新线程

        // 方式2：实现Runnable接口
        Runnable task = () -> System.out.println("t2执行");
        Thread t2 = new Thread(task);
        t2.start(); // 启动新线程
    }
}
```

### **总结**

- **`start()`**：真正启动新线程，实现多线程并发。
- **`run()`**：仅定义线程任务，直接调用等同于普通方法调用。



使用时必须通过`start()`启动线程，否则无法发挥多线程的优势。


## Runnable的run方法和Callable的call方法的区别


### **1. 接口定义与核心区别**

| **特性**     | **`Runnable`**               | **`Callable`**                   |
| ------------ | ---------------------------- | -------------------------------- |
| **方法签名** | `void run()`                 | `V call() throws Exception`      |
| **返回值**   | 无返回值（`void`）           | 有返回值（泛型`V`）              |
| **异常处理** | 不能抛出受检异常             | 可以抛出任意异常                 |
| **使用场景** | 简单的异步任务，无需返回结果 | 需要返回结果或处理异常的异步任务 |

### **2. 代码示例对比**

#### **`Runnable`示例**

java











```java
Runnable task = () -> {
    try {
        Thread.sleep(1000);
    } catch (InterruptedException e) {
        e.printStackTrace(); // 必须捕获异常
    }
    System.out.println("任务执行完成");
};

Thread thread = new Thread(task);
thread.start();
```

#### **`Callable`示例**

java











```java
Callable<Integer> task = () -> {
    Thread.sleep(1000);
    return 42; // 返回结果
};

ExecutorService executor = Executors.newSingleThreadExecutor();
Future<Integer> future = executor.submit(task);
Integer result = future.get(); // 获取结果（可能阻塞）
```

### **3. 返回值与异常处理的差异**

#### **返回值处理**

- **`Runnable`**：无法直接返回结果，若需要结果需通过共享变量或回调函数。
- **`Callable`**：通过`Future`或`CompletableFuture`获取返回值，支持异步计算。

#### **异常处理**

- `Runnable`

  ：

  java











  ```java
  Runnable task = () -> {
      try {
          // 必须在run()内部捕获异常
          throw new IOException("模拟异常");
      } catch (IOException e) {
          e.printStackTrace();
      }
  };
  ```

- `Callable`

  ：

  java











  ```java
  Callable<String> task = () -> {
      if (Math.random() < 0.5) {
          throw new IOException("模拟异常"); // 可直接抛出异常
      }
      return "Success";
  };
  ```

### **4. 适用场景**

#### **`Runnable`适用场景**

- 简单的异步任务，如日志记录、定时任务。
- 无需返回值或异常处理的操作。
- 与`Thread`类直接配合使用。

#### **`Callable`适用场景**

- 计算密集型任务，需要返回计算结果。
- 异步操作可能抛出异常，需要统一处理。
- 配合线程池使用，通过`Future`获取结果。

### **5. 如何选择？**

- **需要返回值**：选择`Callable`。
- **只需执行操作**：选择`Runnable`。
- **异常处理**：若任务可能抛出异常且需要外部处理，选择`Callable`。

### **6. 常见问题解答**

#### **Q1：如何将`Runnable`转换为`Callable`？**

使用`Executors.callable(Runnable task)`或`Executors.callable(Runnable task, T result)`。



java











```java
Runnable runnable = () -> System.out.println("执行任务");
Callable<Object> callable = Executors.callable(runnable, null);
```

#### **Q2：`Future`如何处理异常？**

java











```java
Future<Integer> future = executor.submit(() -> {
    throw new RuntimeException("任务失败");
});

try {
    Integer result = future.get();
} catch (ExecutionException e) {
    Throwable cause = e.getCause(); // 获取实际异常
    cause.printStackTrace();
}
```

#### **Q3：Java 8+ 推荐使用哪种方式？**

推荐使用`CompletableFuture`结合`Callable`，它提供更灵活的异步编程：



java











```java
CompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> {
    return 42; // 类似Callable的call()
});

future.thenApply(result -> result * 2)
      .exceptionally(ex -> 0)
      .thenAccept(System.out::println);
```

### **总结**

| **对比项**   | **`Runnable`**              | **`Callable`**              |
| ------------ | --------------------------- | --------------------------- |
| **返回值**   | 无                          | 有                          |
| **异常处理** | 需内部捕获                  | 可抛出异常                  |
| **接口定义** | `@FunctionalInterface`      | `@FunctionalInterface`      |
| **核心方法** | `void run()`                | `V call() throws Exception` |
| **配合使用** | `Thread`、`ExecutorService` | `ExecutorService`、`Future` |


## Java中的线程池


### 为什么线程池要先使用阻塞队列而不是直接增加线程

因为每创建一个线程都会占用一定的系统资源(如栈空间、线程调度开销等)，直接增加线程会迅速消耗系统资源，
导致性能下降。
使用阻塞队列可以将任务暂存，避免线程数量无限增长，确保资源利用率更高。
如果阻塞队列都满了，说明此时系统负载很大，再去增加线程到最大线程数去消化任务即可，


### 线程数的设定

![img_3.png](img_3.png)


### Java 线程池内部任务出异常后，如何知道是哪个线程出了异常?

### **1. 直接捕获`Future`的异常**

**原理**：通过`Future.get()`获取任务结果时，若任务抛出异常，`get()`会抛出`ExecutionException`，其`getCause()`方法可获取原始异常。



**示例**：



java











```java
ExecutorService executor = Executors.newSingleThreadExecutor();
Future<?> future = executor.submit(() -> {
    throw new RuntimeException("任务异常");
});

try {
    future.get(); // 阻塞等待结果，若任务异常会在此抛出ExecutionException
} catch (ExecutionException e) {
    Throwable cause = e.getCause(); // 获取原始异常
    System.out.println("捕获到异常：" + cause.getMessage());
    StackTraceElement[] stackTrace = cause.getStackTrace();
    System.out.println("异常线程：" + stackTrace[0].getClassName());
}
```





![img](data:image/png;base64,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)



**适用场景**：主动获取`Future`结果的场景，缺点是会阻塞线程。

### **2. 重写`ThreadPoolExecutor`的`afterExecute()`方法**

**原理**：线程池在任务执行完成后会调用`afterExecute(Runnable r, Throwable t)`，可在此方法中捕获异常。



**示例**：



java











```java
ThreadPoolExecutor executor = new ThreadPoolExecutor(
    1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<>()
) {
    @Override
    protected void afterExecute(Runnable r, Throwable t) {
        super.afterExecute(r, t);
        if (t == null && r instanceof Future<?>) {
            try {
                Future<?> future = (Future<?>) r;
                if (future.isDone()) {
                    future.get(); // 检查是否有异常
                }
            } catch (CancellationException ce) {
                t = ce;
            } catch (ExecutionException ee) {
                t = ee.getCause();
            } catch (InterruptedException ie) {
                Thread.currentThread().interrupt();
            }
        }
        if (t != null) {
            System.out.println("线程 " + Thread.currentThread().getName() + " 抛出异常：" + t.getMessage());
        }
    }
};

executor.submit(() -> {
    throw new RuntimeException("测试异常");
});
```



**输出**：



plaintext











```plaintext
线程 pool-1-thread-1 抛出异常：测试异常
```

### **3. 设置`ThreadFactory`的`UncaughtExceptionHandler`**

**原理**：当线程因未捕获的异常终止时，JVM 会调用`UncaughtExceptionHandler`。



**示例**：



java











```java
ThreadFactory factory = r -> {
    Thread t = new Thread(r);
    t.setUncaughtExceptionHandler((thread, ex) -> {
        System.out.println("线程 " + thread.getName() + " 抛出异常：" + ex.getMessage());
    });
    return t;
};

ExecutorService executor = Executors.newSingleThreadExecutor(factory);
executor.execute(() -> {
    throw new RuntimeException("未捕获异常");
});
```



**注意**：此方法仅对`execute()`提交的任务有效，对`submit()`提交的任务无效（因为`submit()`会将异常封装在`Future`中）。

### **4. 自定义`Runnable`/`Callable`包装器**

**原理**：在任务执行前后添加异常处理逻辑。



**示例**：



java











```java
public class ExceptionHandlingRunnable implements Runnable {
    private final Runnable task;

    public ExceptionHandlingRunnable(Runnable task) {
        this.task = task;
    }

    @Override
    public void run() {
        try {
            task.run();
        } catch (Exception e) {
            System.out.println("线程 " + Thread.currentThread().getName() + " 抛出异常：" + e.getMessage());
            throw e;
        }
    }
}

// 使用包装器提交任务
executor.execute(new ExceptionHandlingRunnable(() -> {
    throw new RuntimeException("包装器捕获异常");
}));
```

### **5. 使用`CompletableFuture`的`exceptionally()`方法**

**原理**：`CompletableFuture`提供了专门处理异常的回调。



**示例**：



java











```java
CompletableFuture.runAsync(() -> {
    throw new RuntimeException("异步异常");
}).exceptionally(ex -> {
    System.out.println("捕获异常：" + ex.getMessage());
    return null;
});
```

### **6. 线程池配置参数监控**

通过线程池的`getLargestPoolSize()`、`getCompletedTaskCount()`等方法结合日志，辅助定位异常线程：



java











```java
ThreadPoolExecutor executor = (ThreadPoolExecutor) Executors.newFixedThreadPool(5);
// 定期监控
ScheduledExecutorService monitor = Executors.newSingleThreadScheduledExecutor();
monitor.scheduleAtFixedRate(() -> {
    System.out.println("当前活跃线程数：" + executor.getActiveCount());
    System.out.println("最大线程数：" + executor.getLargestPoolSize());
}, 1, 1, TimeUnit.SECONDS);
```

### **总结与最佳实践**

1. **优先使用`CompletableFuture`**：结合`exceptionally()`和`handle()`方法，优雅处理异常。
2. **重写`afterExecute()`**：适用于统一处理所有任务的异常。
3. **设置`UncaughtExceptionHandler`**：针对未捕获异常，但仅对`execute()`有效。
4. **自定义包装器**：灵活但需要侵入业务代码。
5. **结合监控工具**：如 Prometheus、ELK 等，实时监控线程池状态。



**示例组合使用**：



java











```java
ThreadPoolExecutor executor = new ThreadPoolExecutor(
    5, 10, 60, TimeUnit.SECONDS,
    new LinkedBlockingQueue<>(),
    new CustomThreadFactory("my-pool") // 自定义ThreadFactory设置异常处理器
) {
    @Override
    protected void afterExecute(Runnable r, Throwable t) {
        // 统一处理异常
    }
};

// 使用CompletableFuture提交任务
CompletableFuture.supplyAsync(() -> {
    // 业务逻辑
}, executor).exceptionally(ex -> {
    // 异常处理
    return null;
});
```



通过以上方法，可以有效定位线程池中的异常线程和原因，避免异常被 “静默” 处理


## 时间轮机制

### **一、时间轮的基本原理**

时间轮可以类比为一个 “时钟”，核心组成包括：



- **轮（Wheel）**：环形数组结构，类似时钟的刻度盘。
- **槽（Slot/Bucket）**：轮上的每个元素，每个槽对应一个**时间间隔**（如 1 秒 / 槽），槽内存储该时间点需要执行的**任务列表**。
- **指针（Current Pointer）**：指向当前正在处理的槽，随时间推移定期（每过一个时间间隔）移动到下一个槽，触发并执行该槽内的所有任务。

### **二、单级时间轮的工作流程**

以 “1 秒 / 槽，共 12 个槽” 的单级时间轮为例（总覆盖范围 12 秒）：



1. **添加任务**：当添加一个延迟`T`秒的任务时，计算其对应的槽索引：
   `槽索引 = (当前指针位置 + T) % 总槽数`
   例如：当前指针在槽 0，添加一个延迟 5 秒的任务 → 放入槽 5；添加延迟 15 秒的任务（超过总范围 12 秒），则计算圈数`15 // 12 = 1圈`，剩余`3秒` → 放入槽 3，并记录 “需要多等 1 圈”。
2. **触发任务**：指针每 1 秒移动 1 个槽，每次移动到新槽时：
    - 执行槽内所有 “圈数为 0” 的任务；
    - 对 “圈数> 0” 的任务，圈数减 1（若减到 0 则执行）。

### **三、多级时间轮（提高覆盖范围）**

单级时间轮的覆盖范围有限（总范围 = 槽数 × 时间间隔），为支持更大延迟的任务，引入**多级时间轮**（类似时钟的 “秒→分→时” 层级）：



- **低级轮**：如 “秒轮”（60 槽，1 秒 / 槽，覆盖 60 秒）；
- **中级轮**：如 “分轮”（60 槽，60 秒 / 槽，覆盖 60×60=3600 秒）；
- **高级轮**：如 “时轮”（24 槽，3600 秒 / 槽，覆盖 24×3600=86400 秒）。



**工作流程**：



- 延迟时间超过低级轮范围时，任务会被放入更高级的轮；
- 当高级轮的指针移动时，会将对应槽内的任务 “降级” 到低级轮（计算剩余延迟）；
- 最终任务在低级轮中被触发。



例如：延迟 1 小时 30 分 20 秒的任务：



- 先放入 “时轮” 的 1 槽（1 小时）；
- 时轮指针走到 1 槽时，任务降级到 “分轮” 的 30 槽（30 分钟）；
- 分轮指针走到 30 槽时，任务降级到 “秒轮” 的 20 槽（20 秒）；
- 秒轮指针走到 20 槽时，执行任务。

### **四、时间轮的优势**

相比传统定时器（如 Java 的`Timer`，基于优先级队列，添加 / 删除任务时间复杂度`O(log n)`），时间轮的核心优势是：



1. **高效性**：任务的添加 / 删除操作接近`O(1)`（只需计算槽索引，无需排序）；
2. **批量处理**：每次指针移动仅需处理当前槽的任务，避免全量扫描；
3. **可扩展性**：通过多级时间轮支持超大延迟任务，平衡精度与资源消耗。

### **五、实际应用场景**

时间轮广泛用于中间件、分布式系统中，例如：



- **Netty**：`HashedWheelTimer` 用于处理 I/O 超时（如连接超时、读 / 写超时）；
- **Kafka**：用于处理副本同步超时、消费者组重平衡超时、控制器选举超时等；
- **Dubbo**：用于心跳检测、超时重试等定时任务；
- **Redis**：某些版本中用于过期键删除（结合惰性删除和定期删除）。

### **六、经典实现：Netty 的 HashedWheelTimer**

Netty 的`HashedWheelTimer`是单级时间轮的典型实现，核心参数：



- `tickDuration`：每个槽的时间间隔（精度）；
- `ticksPerWheel`：槽数量（默认 512）；
- `workerThread`：处理任务的线程。



使用示例：



java











```java
// 创建时间轮：100ms/槽，512个槽
HashedWheelTimer timer = new HashedWheelTimer(100, TimeUnit.MILLISECONDS, 512);

// 添加延迟1秒的任务
timer.newTimeout(timeout -> {
    System.out.println("任务执行");
}, 1, TimeUnit.SECONDS);

// 关闭时间轮
timer.stop();
```

### **七、总结**

时间轮通过 “环形结构 + 哈希映射” 实现了高效的定时任务管理，尤其适合**大量、高频、低延迟**的定时场景。其核心特点是：



- 时间复杂度低（`O(1)`级操作）；
- 支持多级扩展，平衡精度与覆盖范围；
- 广泛应用于高性能中间件和分布式系统。
## Timer和ScheduledExecutorService

### **1. 基本用法**

`Timer`配合`TimerTask`（实现了`Runnable`接口）使用，主要方法包括：



- `schedule(TimerTask task, long delay)`：延迟指定毫秒后执行一次任务。
- `schedule(TimerTask task, Date time)`：在指定日期执行一次任务。
- `schedule(TimerTask task, long delay, long period)`：延迟指定毫秒后开始周期性执行任务（固定延迟）。
- `scheduleAtFixedRate(TimerTask task, long delay, long period)`：类似`schedule()`，但使用固定频率执行。
- `cancel()`：终止 Timer，取消所有待执行的任务。



**示例：延迟任务与周期任务**



java











```java
import java.util.Timer;
import java.util.TimerTask;

public class TimerExample {
    public static void main(String[] args) {
        Timer timer = new Timer();

        // 延迟1秒后执行一次
        timer.schedule(new TimerTask() {
            @Override
            public void run() {
                System.out.println("延迟任务执行");
            }
        }, 1000);

        // 延迟2秒后开始，每3秒执行一次
        timer.schedule(new TimerTask() {
            @Override
            public void run() {
                System.out.println("周期任务执行");
            }
        }, 2000, 3000);
    }
}
```

### **2. `schedule()`与`scheduleAtFixedRate()`的区别**

- **`schedule()`**：固定延迟（fixed-delay）。每次执行完成后，等待`period`时间再执行下一次。若某次任务执行时间过长，会导致后续任务延迟，但不会重叠。
- **`scheduleAtFixedRate()`**：固定频率（fixed-rate）。从初始时间开始计算执行周期，若某次任务执行时间过长，可能导致后续任务快速连续执行以 “追赶” 进度。



**示例对比**：



java











```java
// schedule()：固定延迟
timer.schedule(new TimerTask() {
    @Override
    public void run() {
        try {
            Thread.sleep(2000); // 任务执行2秒
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("任务执行完成：" + System.currentTimeMillis());
    }
}, 1000, 1000); // 计划每1秒执行一次，但实际每3秒执行一次（2秒执行+1秒延迟）

// scheduleAtFixedRate()：固定频率
timer.scheduleAtFixedRate(new TimerTask() {
    @Override
    public void run() {
        try {
            Thread.sleep(2000); // 任务执行2秒
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("任务执行完成：" + System.currentTimeMillis());
    }
}, 1000, 1000); // 计划每1秒执行一次，但实际会在任务完成后立即执行下一次（无延迟）
```

### **3. 核心缺陷与局限性**

尽管`Timer`使用简单，但存在以下严重问题，导致其在生产环境中很少被使用：

#### **3.1 单线程设计**

`Timer`内部使用**单个线程**执行所有任务。若某个任务执行时间过长，会阻塞其他任务，甚至导致后续任务完全无法执行。



**示例：任务阻塞**



java











```java
timer.schedule(new TimerTask() {
    @Override
    public void run() {
        try {
            Thread.sleep(5000); // 任务执行5秒
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("长任务执行完成");
    }
}, 1000);

// 另一个任务将被阻塞，直到长任务执行完成
timer.schedule(new TimerTask() {
    @Override
    public void run() {
        System.out.println("短任务执行");
    }
}, 2000);
```

#### **3.2 任务异常会终止整个 Timer**

若某个任务抛出未捕获的异常，`Timer`线程会终止，导致所有待执行的任务都无法继续。



**示例：异常导致 Timer 崩溃**



java











```java
timer.schedule(new TimerTask() {
    @Override
    public void run() {
        throw new RuntimeException("任务异常"); // 会导致整个Timer停止
    }
}, 1000);

// 后续任务无法执行
timer.schedule(new TimerTask() {
    @Override
    public void run() {
        System.out.println("此任务不会执行");
    }
}, 2000);
```

#### **3.3 不支持实时（real-time）调度**

`Timer`依赖系统时间，若系统时间被调整（如 NTP 同步），可能导致任务执行时间异常。

### **4. 替代方案：ScheduledExecutorService**

Java 5 引入的`ScheduledExecutorService`（`java.util.concurrent`包）是`Timer`的**推荐替代品**，解决了上述所有问题：

#### **4.1 多线程支持**

`ScheduledExecutorService`支持创建线程池，可并行执行多个任务，避免相互阻塞。



**示例：创建固定大小的定时线程池**



java











```java
ScheduledExecutorService executor = Executors.newScheduledThreadPool(3); // 3个线程

// 任务1：延迟1秒后执行
executor.schedule(() -> System.out.println("任务1"), 1, TimeUnit.SECONDS);

// 任务2：延迟2秒后开始，每3秒执行一次
executor.scheduleAtFixedRate(() -> {
    try {
        Thread.sleep(1000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    System.out.println("任务2");
}, 2, 3, TimeUnit.SECONDS);
```

#### **4.2 异常处理更健壮**

单个任务的异常不会影响其他任务，可通过`Future`捕获异常。



**示例：捕获任务异常**



java











```java
ScheduledFuture<?> future = executor.schedule(() -> {
    throw new RuntimeException("任务异常");
}, 1, TimeUnit.SECONDS);

try {
    future.get(); // 会抛出ExecutionException
} catch (Exception e) {
    System.out.println("捕获异常：" + e.getCause());
}
```

#### **4.3 更灵活的 API**

提供`scheduleWithFixedDelay()`和`scheduleAtFixedRate()`两种模式，并支持任务取消和关闭。

### **5. 选择建议**

| **场景**           | **推荐工具**                |
| ------------------ | --------------------------- |
| 简单、单任务定时   | `Timer`（不推荐，仅学习用） |
| 多任务、高并发定时 | `ScheduledExecutorService`  |
| 复杂异步任务编排   | `CompletableFuture`         |
| 分布式系统定时任务 | Quartz、XXL-Job             |

### **6. 总结**

`Timer`是 Java 早期的定时工具，因其单线程设计和异常处理缺陷，在现代 Java 应用中已基本被`ScheduledExecutorService`取代。在实际开发中，建议优先使用`ScheduledExecutorService`，它提供了更安全、灵活且高效的定时任务管理能力。



## Java中的累加器

### 一、单线程场景：普通变量累加

在单线程环境下，无需考虑线程安全，直接使用基本数据类型（如`int`、`long`）或包装类即可实现累加，简单高效。

#### 示例：

java











```java
public class SingleThreadAccumulator {
    public static void main(String[] args) {
        int sum = 0;
        for (int i = 0; i < 10; i++) {
            sum += i; // 累加操作
        }
        System.out.println("结果：" + sum); // 输出45
    }
}
```



**特点**：



- 实现简单，性能极高（无额外开销）。
- **线程不安全**：若多线程同时操作，会出现 “丢失更新” 问题（如两个线程同时读取旧值，累加后写回，导致其中一次加操作失效）。

### 二、线程安全的累加器：原子类（Atomic 系列）

Java 在`java.util.concurrent.atomic`包中提供了**原子累加器**，基于**CAS（Compare-And-Swap）** 操作实现线程安全，无需加锁，性能优于`synchronized`同步。

#### 核心类：

- `AtomicInteger`：针对`int`类型的原子累加。
- `AtomicLong`：针对`long`类型的原子累加。
- `AtomicDouble`：（Java 8+）针对`double`类型的原子累加（基于`AtomicLong`间接实现，将`double`转为`long`处理）。

#### 实现原理：

原子类的累加操作（如`addAndGet`）通过**CAS 自旋**实现：



1. 读取当前值`current`。

2. 计算目标值`next = current + delta`。

3. 用 CAS 操作尝试将值从

   ```
   current
   ```

   更新为

   ```
   next
   ```

   ：

    - 若成功（当前值未被其他线程修改），返回`next`。
    - 若失败（当前值已被修改），重复步骤 1-3，直到成功。

#### 用法示例（AtomicInteger）：

java











```java
import java.util.concurrent.atomic.AtomicInteger;

public class AtomicAccumulator {
    public static void main(String[] args) throws InterruptedException {
        AtomicInteger accumulator = new AtomicInteger(0); // 初始值0

        // 多线程累加
        Runnable task = () -> {
            for (int i = 0; i < 1000; i++) {
                accumulator.addAndGet(1); // 累加1，线程安全
            }
        };

        Thread t1 = new Thread(task);
        Thread t2 = new Thread(task);
        t1.start();
        t2.start();
        t1.join();
        t2.join();

        System.out.println("结果：" + accumulator.get()); // 输出2000（线程安全）
    }
}
```

### 三、高性能并发累加器：LongAdder 与 DoubleAdder（Java 8+）

`AtomicLong`在高并发场景下，由于所有线程竞争同一个变量的 CAS 操作，可能导致频繁失败重试，性能下降。



Java 8 引入了`LongAdder`（针对`long`）和`DoubleAdder`（针对`double`），专为**高并发、高吞吐量**的累加场景设计，性能远超`AtomicLong`。

#### 核心原理：“分段累加” 减少竞争

`LongAdder`内部维护一个**基础值（base）** 和一个**数组（cells）**：



- 低并发时，所有线程直接累加`base`，类似`AtomicLong`。
- 高并发时，若多个线程竞争`base`，会自动扩容`cells`数组，让不同线程对不同的`cells`元素进行累加（分散竞争）。
- 最终获取结果时，将`base`与所有`cells`元素的值求和，得到总累加值。

#### 优缺点：

- **优点**：高并发下通过分散竞争，大幅提升写操作（累加）性能。
- **缺点**：获取结果（`sum()`）时需要汇总所有分段值，比`AtomicLong.get()`稍慢，适合 “写多读少” 场景。

#### 用法示例（LongAdder）：

java











```java
import java.util.concurrent.atomic.LongAdder;

public class LongAdderDemo {
    public static void main(String[] args) throws InterruptedException {
        LongAdder adder = new LongAdder();

        Runnable task = () -> {
            for (int i = 0; i < 10000; i++) {
                adder.increment(); // 累加1，高并发下性能优于AtomicLong
            }
        };

        // 启动100个线程并发累加
        Thread[] threads = new Thread[100];
        for (int i = 0; i < 100; i++) {
            threads[i] = new Thread(task);
            threads[i].start();
        }
        for (Thread t : threads) {
            t.join();
        }

        System.out.println("结果：" + adder.sum()); // 输出1000000（正确）
    }
}
```

### 四、对比总结

| 累加器类型      | 线程安全 | 高并发性能     | 适用场景                       |
| --------------- | -------- | -------------- | ------------------------------ |
| 普通变量（int） | 否       | 极高（单线程） | 单线程累加                     |
| AtomicInteger   | 是       | 中低并发优秀   | 中低并发，需频繁获取中间结果   |
| LongAdder       | 是       | 高并发优秀     | 高并发，写多读少（如统计计数） |

### 五、扩展：累加器的其他实现

- **同步方法 / 代码块**：通过`synchronized`或`ReentrantLock`保证线程安全，但性能较差，适合低并发场景。
- **自定义累加器**：基于`AtomicReference`实现对象类型的累加（如累加自定义数值对象）。



综上，Java 中的累加器从简单到复杂，从非线程安全到高性能并发安全，可根据实际并发量和读写频率选择最合适的实现。高并发场景下，优先选择`LongAdder`；中低并发或需频繁读中间结果，选择`AtomicInteger/AtomicLong`。


## 如何判断线程池已经执行完所有任务了

### **1. 使用 `awaitTermination()` 阻塞等待**

**场景**：需要等待所有任务执行完毕后再继续主线程。
**方法**：

java



运行









```java
// 关闭线程池（不再接受新任务，但已提交的任务会继续执行）
executor.shutdown();

// 阻塞等待所有任务完成，超时则返回 false
try {
    if (executor.awaitTermination(1, TimeUnit.HOURS)) {
        System.out.println("所有任务已完成");
    } else {
        System.out.println("超时，仍有任务未完成");
    }
} catch (InterruptedException e) {
    System.out.println("等待被中断");
    Thread.currentThread().interrupt();
}
```





![img](data:image/png;base64,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)

**注意**：

- 必须先调用 `shutdown()` 或 `shutdownNow()`，否则 `awaitTermination()` 会一直等待。
- `awaitTermination()` 的超时参数需合理设置，避免无限等待。

### **2. 通过 `isTerminated()` 判断**

**场景**：定期检查线程池是否已完全终止（所有任务完成且线程池已关闭）。
**方法**：

java



运行









```java
executor.shutdown(); // 先关闭线程池

while (!executor.isTerminated()) {
    // 线程池未完全终止，可执行其他操作（如打印进度）
    System.out.println("等待任务完成...");
    Thread.sleep(1000);
}

System.out.println("所有任务已完成，线程池已终止");
```

**注意**：

- `isTerminated()` 返回 `true` 的前提是：已调用 `shutdown()` 或 `shutdownNow()`，且所有任务已执行完毕。
- 若未调用 `shutdown()`，`isTerminated()` 永远为 `false`。

### **3. 统计任务完成数（适用于自定义任务计数）**

**场景**：精确跟踪已完成的任务数量，不依赖线程池状态。
**实现**：

java



运行









```java
import java.util.concurrent.*;

public class TaskCounterExample {
    private static final ExecutorService executor = Executors.newFixedThreadPool(5);
    private static final AtomicInteger totalTasks = new AtomicInteger(0);
    private static final AtomicInteger completedTasks = new AtomicInteger(0);

    public static void main(String[] args) {
        // 提交10个任务
        for (int i = 0; i < 10; i++) {
            totalTasks.incrementAndGet();
            executor.submit(() -> {
                try {
                    // 模拟任务执行
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                } finally {
                    completedTasks.incrementAndGet();
                }
            });
        }

        // 等待所有任务完成
        while (completedTasks.get() < totalTasks.get()) {
            System.out.printf("已完成: %d / %d%n", completedTasks.get(), totalTasks.get());
            Thread.sleep(500);
        }

        System.out.println("所有任务已完成");
        executor.shutdown();
    }
}
```

**优势**：

- 无需关闭线程池，可在任务执行过程中动态跟踪进度。
- 适用于持续提交任务的场景（如生产者 - 消费者模式）。

### **4. 使用 `CountDownLatch` 同步**

**场景**：明确知道任务数量，需等待所有任务完成后触发后续操作。
**实现**：

java



运行









```java
import java.util.concurrent.*;

public class CountDownLatchExample {
    public static void main(String[] args) throws InterruptedException {
        ExecutorService executor = Executors.newFixedThreadPool(5);
        int taskCount = 10;
        CountDownLatch latch = new CountDownLatch(taskCount);

        // 提交10个任务
        for (int i = 0; i < taskCount; i++) {
            executor.submit(() -> {
                try {
                    // 模拟任务执行
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                } finally {
                    latch.countDown(); // 任务完成，计数器减1
                }
            });
        }

        // 等待所有任务完成
        latch.await(); // 阻塞直到计数器为0
        System.out.println("所有任务已完成");
        executor.shutdown();
    }
}
```

**优势**：

- 代码简洁，无需手动管理任务计数。
- 可配合 `await(timeout, unit)` 设置超时，避免无限等待。

### **5. 使用 `Future` 跟踪所有任务**

**场景**：需获取每个任务的执行结果，并确保所有任务完成。
**实现**：

java



运行









```java
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.*;

public class FutureExample {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(5);
        List<Future<?>> futures = new ArrayList<>();

        // 提交任务并保存 Future
        for (int i = 0; i < 10; i++) {
            Future<?> future = executor.submit(() -> {
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
                return null;
            });
            futures.add(future);
        }

        // 检查所有任务是否完成
        for (Future<?> future : futures) {
            try {
                future.get(); // 阻塞直到任务完成，若任务异常会抛出 ExecutionException
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }
        }

        System.out.println("所有任务已完成");
        executor.shutdown();
    }
}
```

**优势**：

- 可获取任务的返回值或处理异常。
- 若任务抛出异常，`future.get()` 会立即抛出 `ExecutionException`，便于快速定位问题。

### **总结与选择建议**

| **方法**             | **适用场景**                               | **是否需关闭线程池** | **是否阻塞主线程** |
| -------------------- | ------------------------------------------ | -------------------- | ------------------ |
| `awaitTermination()` | 需等待所有任务完成后继续执行后续逻辑       | 是                   | 是                 |
| `isTerminated()`     | 定期检查线程池是否已完全终止               | 是                   | 否                 |
| 自定义任务计数器     | 动态跟踪任务进度，持续提交任务的场景       | 否                   | 否                 |
| `CountDownLatch`     | 明确任务数量，需等待所有任务完成后触发操作 | 否                   | 是                 |
| `Future.get()`       | 需获取任务结果或处理异常                   | 否                   | 是                 |

**建议**：

- 若需等待所有任务完成后继续执行，优先使用 `awaitTermination()`。
- 若需精确控制任务计数并动态显示进度，使用自定义计数器或 `CountDownLatch`。
- 若需获取任务结果或处理异常，使用 `Future`。


## 标记复制和标记整理都会移动存活对象，具体是怎么做对这些对象的引用的变更的


### **标记复制（Mark-Copy）**

#### **核心流程**

1. **标记阶段**：从根对象出发，标记所有存活对象。
2. **复制阶段**：将存活对象按顺序复制到新的内存区域（通常是空闲区域或另一块堆空间）。
3. **更新引用**：修改所有指向原对象的引用，使其指向新的内存地址。
4. **清理原区域**：回收原内存区域的所有空间。

#### **引用变更实现**

- 对象表（Object Table）

  ：在复制过程中，GC 维护一个映射表，记录每个对象的原地址和新地址。例如：

  plaintext











  ```plaintext
  原地址 A → 新地址 A'
  原地址 B → 新地址 B'
  ```

- **扫描栈和寄存器**：GC 遍历线程栈和 CPU 寄存器，将其中保存的对象引用从原地址更新为新地址（通过查表实现）。

- **扫描堆内存**：递归遍历新区域中的所有对象，更新其内部的引用字段。例如，若对象 A' 引用对象 B，则将 B 替换为 B'。

### **标记整理（Mark-Compact）**

#### **核心流程**

1. **标记阶段**：与标记复制相同，标记所有存活对象。
2. **计算移动位置**：确定每个存活对象在整理后的新位置（通常按内存地址连续排列）。
3. **移动对象**：将存活对象依次移动到新位置。
4. **更新引用**：修改所有指向原对象的引用，使其指向新地址。

#### **引用变更实现**

- 双指针法

  ：在移动对象时，使用两个指针：

    - **扫描指针**：指向当前正在处理的对象。
    - **空闲指针**：指向整理后内存区域的下一个空闲位置。

- 转发指针（Forwarding Pointer）

  ：

    - 在对象被移动后，原内存位置会留下一个 “转发指针”，指向新地址。
    - 当 GC 扫描到引用原地址的对象时，通过转发指针找到新地址并更新引用。

- 分阶段更新

  ：

    - **第一阶段**：移动所有对象，并在原位置设置转发指针。
    - **第二阶段**：遍历所有引用（包括栈、寄存器和堆中的对象），通过转发指针更新为新地址。
    - **第三阶段**：清理所有转发指针。

### **关键区别**

| **标记复制**                     | **标记整理**                       |
| -------------------------------- | ---------------------------------- |
| 需额外内存空间（通常为堆的一半） | 无需额外空间（原地整理）           |
| 引用更新在复制后一次性完成       | 引用更新分阶段进行（移动后再更新） |
| 对象按顺序复制，内存连续         | 对象按计算的新位置移动，内存连续   |
| 适合对象存活率低的场景           | 适合对象存活率高的场景             |

### **示例说明**

#### **标记复制**

plaintext











```plaintext
原内存布局：[A, B, C, D] （A、C存活，B、D死亡）
复制后：   [A', C'] （新区域）
引用更新：所有指向 A 的引用 → A'，指向 C 的引用 → C'
```






#### **标记整理**

plaintext











```plaintext
原内存布局：[A, B, C, D] （A、C存活，B、D死亡）
计算位置： A → 新位置0，C → 新位置1
移动后：   [A', C'] （原区域）
引用更新：所有指向 A 的引用 → A'，指向 C 的引用 → C'
```






### **总结**

- **标记复制**通过对象表和一次性扫描更新引用，实现简单但需额外空间。
- **标记整理**通过转发指针分阶段更新引用，节省空间但实现复杂。
- 两者均通过 “地址映射表” 或 “转发指针” 确保引用的正确性，核心是在对象移动后，让所有引用指向新地址。

## 三种标记方法的比较


### **1. 标记 - 清除（Mark-Sweep）**

#### **流程**

1. **标记阶段**：从根对象（如栈、静态变量）出发，递归遍历并标记所有可达对象。
2. **清除阶段**：扫描整个堆，回收未被标记的对象（即垃圾）。

#### **特点**

- **不移动对象**：存活对象保持原位，仅释放死亡对象的内存。
- **产生内存碎片**：回收后的内存空间可能不连续，导致后续大对象分配困难。
- **简单高效**：实现简单，适合短期存活对象比例高的场景。

#### **缺点**

- 内存碎片化严重，可能导致提前触发 GC。
- 清除阶段需遍历整个堆，效率较低。

### **2. 标记 - 复制（Mark-Copy）**

#### **流程**

1. **标记阶段**：同标记 - 清除，标记所有存活对象。
2. **复制阶段**：将存活对象按顺序复制到另一块空闲内存区域（通常是堆的一半）。
3. **更新引用**：修改所有指向原对象的引用，使其指向新地址。
4. **清空原区域**：一次性回收整个原区域的内存。

#### **特点**

- **内存连续**：复制后存活对象连续排列，无碎片。
- **高效分配**：新对象直接在空闲区域的末尾分配（通过指针碰撞）。
- **空间代价高**：需预留一半堆空间用于复制。

#### **缺点**

- 空间利用率低（仅使用一半堆）。
- 复制操作对大对象或存活率高的场景开销大。

### **3. 标记 - 整理（Mark-Compact）**

#### **流程**

1. **标记阶段**：同前两种方法，标记存活对象。
2. **计算位置**：确定存活对象在整理后的新位置（通常按内存地址连续排列）。
3. **移动对象**：将存活对象依次移动到新位置。
4. **更新引用**：修改所有指向原对象的引用，使其指向新地址。

#### **特点**

- **无内存碎片**：移动后内存连续，支持高效分配。
- **空间利用率高**：无需预留额外空间（对比标记 - 复制）。
- **适合高存活率场景**：避免频繁复制大对象。

#### **缺点**

- 移动对象和更新引用的开销较大，实现复杂度高。
- 移动过程中需暂停用户线程（STW 时间较长）。

### **核心区别对比**

| **特性**     | **标记 - 清除**          | **标记 - 复制**      | **标记 - 整理**             |
| ------------ | ------------------------ | -------------------- | --------------------------- |
| **内存移动** | 否                       | 是（复制到新区域）   | 是（原地移动）              |
| **内存碎片** | 严重                     | 无                   | 无                          |
| **空间需求** | 单份堆空间               | 双倍堆空间           | 单份堆空间                  |
| **分配效率** | 低（需遍历空闲列表）     | 高（指针碰撞）       | 高（指针碰撞）              |
| **适用场景** | 短期对象多、碎片容忍度高 | 存活率低、对象体积小 | 存活率高、大对象多          |
| **典型实现** | 早期 JVM 的 Serial GC    | 新生代的 Scavenge GC | 老年代的 CMS、G1 的部分阶段 |