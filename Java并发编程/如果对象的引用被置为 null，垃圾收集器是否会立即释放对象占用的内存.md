不会。当对象的引用被置为`null`时，只是切断了该引用与对象之间的关联，使对象成为 “不可达对象”（满足被垃圾收集的**必要条件**），但垃圾收集器（GC）**不会立即释放其占用的内存**。具体原因如下：

### 1. 垃圾收集器的运行时机由 JVM 决定

Java 的垃圾收集器是**自动调度的**，其运行时机由 JVM 根据内存使用情况（如堆内存不足、达到特定阈值等）动态决定，而非由代码直接控制。即使对象已不可达，GC 也不会 “立刻” 执行回收，而是需要等待 JVM 触发 GC 周期（例如 Minor GC、Major GC 等）。

例如，你可以调用`System.gc()`建议 JVM 执行 GC，但这只是 “建议”，JVM 可以选择忽略（实际开发中也不推荐依赖此方法）。

### 2. 垃圾收集的流程需要时间

即使 GC 开始运行，回收对象也需要经过一系列流程（如**标记 - 清除**、**标记 - 整理**、**复制**等，不同 GC 算法流程不同）：

- **标记阶段**：GC 需要遍历所有可达对象，标记出不可达对象（包括被置为`null`后不可达的对象）；
- **清除 / 整理阶段**：删除不可达对象，并整理内存碎片（部分算法）。

这个过程本身需要时间，且是批量处理的（一次性回收多个不可达对象），因此单个对象的引用被置为`null`后，不会被 “即时” 处理。

### 3. 特殊场景：对象可能被其他引用持有

即使某个引用被置为`null`，如果对象仍被其他引用（如其他变量、集合、静态变量等）持有，它依然是 “可达的”，不会被回收。只有当对象**没有任何引用指向它**（即完全不可达）时，才会被 GC 标记为可回收对象。

### 总结

- 对象引用被置为`null`，仅表示该对象 “可能会被回收”（前提是无其他引用），但这只是回收的 “前提条件”；
- 内存释放的实际执行依赖于 JVM 的 GC 调度，**不存在 “立即释放” 的机制**；
- GC 的核心作用是 “自动管理内存”，开发者无需手动控制回收时机，只需确保不再使用的对象及时脱离引用链（如置为`null`、退出作用域等）即可。