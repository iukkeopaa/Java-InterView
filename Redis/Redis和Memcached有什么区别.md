### **1. 数据结构支持**

- **Memcached**：仅支持 **单一的键值对结构**，且值只能是字符串（二进制安全）。所有操作都是简单的 `set/get`，无法对值进行复杂处理。
- **Redis**：支持 **丰富的数据结构**，包括字符串（String）、哈希（Hash）、列表（List）、集合（Set）、有序集合（Sorted Set），以及位图（Bitmap）、HyperLogLog、地理空间（Geo）等。
  例如：用有序集合实现排行榜，用列表实现消息队列，用哈希存储对象属性，这些都是 Memcached 无法直接支持的。

### **2. 持久化能力**

- **Memcached**：**不支持持久化**，数据完全存储在内存中，服务重启或崩溃后数据会全部丢失。适用于 “丢数据不影响核心业务” 的场景（如临时缓存）。

- Redis

  ：支持两种持久化机制：

    - **RDB**：定期生成内存快照（二进制文件），适合备份和灾难恢复。
    - **AOF**：记录所有写操作日志（文本），重启时重放日志恢复数据，可靠性更高（可配置刷盘策略）。
      持久化让 Redis 可用于 “需要数据持久化” 的场景（如分布式锁、计数器）。

### **3. 集群与分布式支持**

- **Memcached**：**无原生集群支持**，需依赖客户端实现分布式（如一致性哈希），服务端仅作为单节点工作，扩容和高可用需手动维护。
- **Redis**：从 3.0 开始支持 **原生集群（Redis Cluster）**，自动实现数据分片（哈希槽）、故障转移和高可用，无需依赖客户端，适合大规模部署。

### **4. 线程模型**

- **Memcached**：采用 **多线程模型**（主线程监听连接，工作线程处理请求），能有效利用多核 CPU 处理并发连接，适合高并发简单操作。
- **Redis**：核心命令处理采用 **单线程模型**（基于 IO 多路复用），避免了多线程切换的开销。
  注：Redis 4.0 后引入多线程处理 **网络 IO**（命令执行仍为单线程），进一步提升了大流量场景的性能。
  实际性能中，Redis 单线程处理内存操作极快（微秒级），小数据场景下性能甚至优于 Memcached；但 CPU 密集型操作（如复杂计算）可能成为瓶颈。

### **5. 内存管理**

- **Memcached**：采用 **Slab Allocation** 机制，将内存划分为固定大小的 “块”（Slab），分配给不同大小的键值对。
  缺点：存储大小差异大的数据时，易产生内存碎片，浪费空间。
- **Redis**：使用 **jemalloc/tcmalloc** 等内存分配器，动态分配内存，内存利用率更高（尤其对小数据）。
  此外，Redis 支持 **内存淘汰策略**（如 LRU、LFU），当内存不足时自动删除 “不常用” 数据，而 Memcached 仅支持简单的内存满后拒绝写入。

### **6. 功能扩展**

- **Memcached**：功能极简，仅提供基础的 `set/get/delete` 等命令，无额外扩展。

- Redis

  ：支持丰富的高级功能：

    - **发布订阅（Pub/Sub）**：实现简单的消息通知。
    - **Lua 脚本**：原子执行复杂逻辑（如分布式锁的 `setnx + expire` 原子化）。
    - **事务（Transaction）**：通过 `MULTI/EXEC` 保证命令的原子性（乐观锁机制）。
    - **Stream**：类似 Kafka 的消息队列功能（支持消费组、持久化）。

### **7. 适用场景**

- **Memcached**：
  适合 **简单、高频的键值缓存场景**，例如：
    - 会话存储（Session Cache）、页面静态数据缓存。
    - 对性能要求极高，但数据结构简单、无需持久化的场景。
- **Redis**：
  适合 **复杂业务逻辑 + 缓存 / 存储结合的场景**，例如：
    - 复杂数据结构需求（如排行榜、购物车、实时计数器）。
    - 需要持久化（防止数据丢失）或分布式部署（集群）的场景。
    - 替代部分数据库功能（如高频访问的热点数据存储）。

### **总结**

- Memcached 是 “轻量型键值缓存”，优势在于简单、高性能（多线程处理并发），但功能单一。
- Redis 是 “多功能内存数据库”，优势在于丰富的数据结构、持久化和扩展性，适合复杂业务场景。

选择时需根据业务需求判断：若仅需简单缓存，Memcached 足够；若需复杂逻辑或持久化，Redis 是更优解