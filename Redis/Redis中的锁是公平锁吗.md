### 一、核心概念：公平锁 vs 非公平锁

- **公平锁**：多个线程 / 客户端获取锁的顺序，严格遵循 “先请求先获取” 的原则（类似排队），不会出现后请求的客户端 “插队” 获取锁的情况。
- **非公平锁**：锁释放后，所有等待的客户端随机竞争，可能出现后请求的客户端先获取锁（“插队”），性能通常更高，但可能导致某些客户端长期饥饿。

### 二、Redis 分布式锁的默认实现（非公平）

最常见的 Redis 分布式锁实现基于`SET`命令（带`NX`和`EX`参数），例如：



bash











```bash
# 尝试获取锁，键为lock_key，值为唯一标识（如UUID），仅在键不存在时设置（NX），过期时间10秒（EX）
SET lock_key <uuid> NX EX 10
```








这种实现的**非公平性体现在**：



1. 当锁释放（`DEL lock_key`）后，所有等待的客户端会重新发起`SET`命令竞争锁，Redis 单线程处理命令时，谁的`SET`命令先到达服务器，谁就会成功获取锁。
2. 由于网络延迟、客户端处理速度差异等，后发起请求的客户端可能因网络更快而先到达 Redis，“插队” 获取锁，破坏 “先请求先获取” 的顺序。

### 三、如何实现 Redis 公平锁？

要实现公平锁，需要额外机制维护 “等待队列”，确保按请求顺序分配锁。典型实现如**Redisson 的`FairLock`**，核心逻辑是：



1. 客户端请求锁时，先向一个**有序集合（Sorted Set）** 中添加自己的标识（以请求时间戳为分数，保证顺序）。
2. 只有队列中排在首位的客户端，才能尝试获取锁；其他客户端需监听前序客户端的释放事件（通过 Redis 的`Pub/Sub`机制）。
3. 锁释放时，移除首位客户端的标识，并通知下一位客户端尝试获取锁。



这种方式严格保证了 “先请求先获取”，但会引入额外的 Redis 操作（维护队列、发布订阅），性能略低于非公平锁。

### 四、公平锁 vs 非公平锁的取舍

| 维度       | 非公平锁（默认）         | 公平锁（如 Redisson FairLock） |
| ---------- | ------------------------ | ------------------------------ |
| 性能       | 更高（无队列维护开销）   | 略低（需维护队列和发布订阅）   |
| 公平性     | 无（可能插队）           | 有（严格按顺序）               |
| 实现复杂度 | 简单（仅需`SET`命令）    | 复杂（需队列 + 监听机制）      |
| 适用场景   | 追求高性能，允许短期饥饿 | 需严格顺序（如分布式任务调度） |

### 五、总结

- **默认情况下，Redis 分布式锁是非公平锁**：基于`SET NX EX`的简单实现不保证顺序，依赖命令到达 Redis 的时机竞争。
- **公平锁需额外实现**：通过维护等待队列（如 Redisson 的`FairLock`）确保顺序，但会牺牲部分性能。
- 选择时需权衡：大多数场景优先用非公平锁（性能更高），仅在必须保证顺序时才用公平锁。