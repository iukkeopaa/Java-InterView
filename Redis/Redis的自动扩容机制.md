在 Redis 中，**渐进式哈希（Progressive Rehashing）** 是一种用于解决哈希表扩容 / 缩容时性能问题的优化机制。其核心目的是避免因一次性迁移大量数据导致的主线程阻塞，通过分批次、渐进式地迁移数据，分散操作开销，保证 Redis 的高性能。

### 背景：哈希表的 Rehash 需求

Redis 的字典（`dict`，用于实现 Hash、Set 等数据结构）底层依赖哈希表（`hash table`）存储键值对。哈希表的性能依赖于**负载因子**（`load factor`，即已使用节点数 / 总节点数）：



- 负载因子过高（如数据过多）：哈希冲突概率增加，查询效率下降；
- 负载因子过低（如数据过少）：内存浪费严重。



因此，当负载因子超过阈值时，Redis 需要对哈希表进行**重哈希（Rehash）**：创建一个更大（扩容）或更小（缩容）的新哈希表，将旧哈希表中的数据迁移到新哈希表中，以调整负载因子至合理范围。



若直接一次性将所有数据从旧哈希表迁移到新哈希表（即 “一次性 Rehash”），当数据量极大时（如百万级键值对），会导致 Redis 主线程阻塞数十毫秒甚至更长时间，这与 Redis “单线程高性能” 的设计目标冲突。

### 渐进式哈希的核心思想

渐进式哈希的本质是：**将哈希表的 Rehash 操作拆分为多个小步骤，在多次字典操作中逐步完成数据迁移**，而非一次性完成。具体来说，通过 “双哈希表 + 分批次迁移” 实现。

### 渐进式哈希的实现细节

#### 1. 双哈希表结构

Redis 的字典中维护了两个哈希表：`ht[0]`（旧表）和`ht[1]`（新表）。



- 正常情况下，数据只存在于`ht[0]`；
- 当需要 Rehash 时，会创建`ht[1]`（根据扩容 / 缩容需求设置新大小），并开始渐进式迁移数据。

#### 2. Rehash 的触发条件

Rehash（扩容 / 缩容）的触发由负载因子决定：



- 扩容

  ：当哈希表负载因子（

  ```
  ht[0].used / ht[0].size
  ```

  ）满足以下条件时触发：

    - 负载因子 ≥ 1，且 Redis 未在执行`BGSAVE`/`BGREWRITEAOF`（避免内存碎片）；
    - 负载因子 ≥ 5（强制扩容，无论是否有后台操作）。

- **缩容**：当负载因子 < 0.1 时触发（释放空闲内存）。

#### 3. 渐进式迁移过程

Rehash 开始后，Redis 通过一个**迁移索引（`rehashidx`）** 记录迁移进度（初始为 0，标识未开始；迁移时为当前处理的桶索引；完成后为 - 1）。



迁移步骤如下：



1. 当触发 Rehash 时，初始化`ht[1]`（设置新大小，通常为`ht[0]`的 2 倍或 1/2），并将`rehashidx`设为 0（开始迁移）。
2. 每次执行字典操作（如增、删、改、查）时，除了处理当前操作，会顺带将`ht[0]`中`rehashidx`索引对应的桶（`bucket`）内所有键值对迁移到`ht[1]`，并将`rehashidx`递增 1。
3. 重复步骤 2，直到`ht[0]`中所有数据迁移完成（`rehashidx`达到`ht[0].size`），此时将`ht[1]`设置为`ht[0]`，清空`ht[1]`，并将`rehashidx`设为 - 1（结束 Rehash）。

#### 4. Rehash 期间的操作处理

在渐进式 Rehash 过程中，字典的所有操作（增、删、改、查）需要同时处理`ht[0]`和`ht[1]`，以保证数据一致性：



- **查询 / 删除**：先在`ht[0]`中查找，若未找到则在`ht[1]`中查找（删除同理）。
- **插入**：直接插入到`ht[1]`（新数据不再进入旧表，加速`ht[0]`的清空）。
- **更新**：若键在`ht[0]`中，则更新后迁移到`ht[1]`；若在`ht[1]`中，则直接更新。

### 优势

渐进式哈希通过 “分而治之” 的思想，将原本可能阻塞主线程的大量数据迁移，分散到多次字典操作中，每次迁移仅处理少量数据（一个桶），从而避免了长时间阻塞，保证了 Redis 的高响应性。这是 Redis 单线程模型下维持高性能的关键优化之一。



总结来说，渐进式哈希是 Redis 应对哈希表动态调整的核心机制，通过双表并行、分批次迁移、操作兼容等设计，在保证数据一致性的同时，最大化减少了 Rehash 对性能的影响。