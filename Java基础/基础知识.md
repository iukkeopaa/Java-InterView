## char 型变量中能存储一个中文汉字吗？

在 Java 中，char 型变量可以存储一个中文汉字。

Java 中的字符采用 Unicode 编码，char 类型占两个字节，而一个汉字在 Unicode 编码中通常也占两个字节，所以 char 类型可以存储一个汉字。

例如：
```java
char c = ‘中’;
System.out.println(c);
```
上述代码会正确输出汉字“中”。


## 枚举能否继承其他类？能否实现接口？

### **1. 枚举能否继承其他类？**

**不能直接继承其他类**，但枚举类本身隐式继承自 `java.lang.Enum`。具体说明如下：



- **隐式继承**：所有枚举类都默认继承自 `java.lang.Enum`，无法显式继承其他类（包括抽象类）。
- **单继承限制**：Java 不支持多重继承，因此枚举不能同时继承 `Enum` 和其他类。



java



运行









```java
// 错误示例：无法显式继承其他类
enum Color extends MyClass {  // 编译错误！
    RED, GREEN, BLUE;
}
```

### **2. 枚举能否实现接口？**

**可以实现接口**，且可以为每个枚举常量提供不同的实现。具体说明如下：



- **实现方式**：枚举类可以实现一个或多个接口。
- **常量级实现**：每个枚举常量可以单独重写接口方法，提供不同的行为。



java



运行









```java
// 接口定义
interface Printable {
    void print();
}

// 枚举实现接口
enum Color implements Printable {
    RED {
        @Override
        public void print() {
            System.out.println("This is red.");
        }
    },
    GREEN {
        @Override
        public void print() {
            System.out.println("This is green.");
        }
    },
    BLUE {
        @Override
        public void print() {
            System.out.println("This is blue.");
        }
    };
}

// 使用示例
Color.RED.print();  // 输出：This is red.
```

```java
public interface Operation {
    double apply(double x, double y);
}

public enum BasicOperation implements Operation {
    PLUS("+") {
        public double apply(double x, double y) { return x + y; }
    },
    MINUS("-") {
        public double apply(double x, double y) { return x - y; }
    },
    TIMES("*") {
        public double apply(double x, double y) { return x * y; }
    },
    DIVIDE("/") {
        public double apply(double x, double y) {
            if (y == 0) throw new ArithmeticException("Cannot divide by zero");
            return x / y;
        }
    };

    private final String symbol;

    BasicOperation(String symbol) {
        this.symbol = symbol;
    }

    public String getSymbol() {
        return symbol;
    }
}
```

### **3. 枚举的其他特性**

- **常量不可变**：枚举常量是单例的，不可实例化新对象。
- **构造器私有**：枚举的构造器必须是私有的（默认隐式私有）。
- **可定义方法和字段**：枚举可以包含方法、字段和构造器。



java



运行









```java
enum Season {
    SPRING("Warm"), SUMMER("Hot"), AUTUMN("Cool"), WINTER("Cold");

    private final String description;

    Season(String description) {  // 构造器默认 private
        this.description = description;
    }

    public String getDescription() {
        return description;
    }
}
```






### **总结**

| **特性**       | **能否实现** | **说明**                                      |
| -------------- | ------------ | --------------------------------------------- |
| 继承其他类     | ? 否         | 隐式继承 `java.lang.Enum`，无法显式继承其他类 |
| 实现接口       | ? 是         | 可以实现多个接口，每个常量可单独重写接口方法  |
| 定义构造器     | ? 是         | 构造器必须为私有，用于初始化枚举常量的属性    |
| 定义方法和字段 | ? 是         | 可以包含静态 / 实例方法、字段                 |

## 反射中如何获取类的所有公共方法和属性？如何获取所有方法和属性（包括私有）？

在 Java 反射中，可以通过以下方式获取类的方法和属性：

**一、获取类的所有公共方法和属性**

1. 获取公共方法：

    - 使用Class类的getMethods()方法可以获取类的所有公共方法，包括从父类继承的方法。该方法返回一个Method数组。

    - 示例代码：

      ```
      import java.lang.reflect.Method;
      
      public class MyClass {
          public void publicMethod() {
              System.out.println("This is a public method.");
          }
      }
      
      public class Main {
          public static void main(String[] args) {
              try {
                  Class<?> clazz = Class.forName("MyClass");
                  Method[] methods = clazz.getMethods();
                  for (Method method : methods) {
                      System.out.println("Method name: " + method.getName());
                  }
              } catch (ClassNotFoundException e) {
                  e.printStackTrace();
              }
          }
      }
      ```



2. 获取公共属性：

    - 使用Class类的getFields()方法可以获取类的所有公共属性，包括从父类继承的属性。该方法返回一个Field数组。

    - 示例代码：

      ```
      import java.lang.reflect.Field;
      
      public class MyClass {
          public int publicField;
      }
      
      public class Main {
          public static void main(String[] args) {
              try {
                  Class<?> clazz = Class.forName("MyClass");
                  Field[] fields = clazz.getFields();
                  for (Field field : fields) {
                      System.out.println("Field name: " + field.getName());
                  }
              } catch (ClassNotFoundException e) {
                  e.printStackTrace();
              }
          }
      }
      ```



**二、获取类的所有方法和属性（包括私有）**

1. 获取所有方法：

    - 使用Class类的getDeclaredMethods()方法可以获取类自身声明的所有方法，包括私有方法。该方法返回一个Method数组。如果要获取包括父类的所有方法，可以结合使用getMethods()和遍历父类的方式。

    - 为了能够访问私有方法，需要使用setAccessible(true)方法来取消访问检查。

    - 示例代码：

      ```
      import java.lang.reflect.Method;
      
      public class MyClass {
          private void privateMethod() {
              System.out.println("This is a private method.");
          }
      }
      
      public class Main {
          public static void main(String[] args) {
              try {
                  Class<?> clazz = Class.forName("MyClass");
                  Method[] methods = clazz.getDeclaredMethods();
                  for (Method method : methods) {
                      method.setAccessible(true);
                      System.out.println("Method name: " + method.getName());
                  }
              } catch (ClassNotFoundException | SecurityException e) {
                  e.printStackTrace();
              }
          }
      }
      ```



2. 获取所有属性：

    - 使用Class类的getDeclaredFields()方法可以获取类自身声明的所有属性，包括私有属性。该方法返回一个Field数组。如果要获取包括父类的所有属性，可以结合使用getFields()和遍历父类的方式。

    - 为了能够访问私有属性，需要使用setAccessible(true)方法来取消访问检查。

    - 示例代码：

      ```
      import java.lang.reflect.Field;
      
      public class MyClass {
          private int privateField;
      }
      
      public class Main {
          public static void main(String[] args) {
              try {
                  Class<?> clazz = Class.forName("MyClass");
                  Field[] fields = clazz.getDeclaredFields();
                  for (Field field : fields) {
                      field.setAccessible(true);
                      System.out.println("Field name: " + field.getName());
                  }
              } catch (ClassNotFoundException | SecurityException e) {
                  e.printStackTrace();
              }
          }
      }
      ```
      


## 方法优先调用可选参数还是固定参数 固定参数

## 可选参数注意事项

1. 可选参数是从0到无穷
2. 一个方法只能有一个可选参数
3. 可选参数必须要放在方法最后
4. 可选参数和其他同名方法组成方法重载
5. 当程序中有固定参数和可选参数时，优先调用固定参数，而非可选参数。

## 参数匹配过程

#### 第1优先级：精准参数匹配

方法重载会优先调用和方法参数类型一模一样的固定参数方法。

#### 第2优先级：调用基本类型自动转换成更大的基本类型

如果是基本数据类型，那么方法重载调用的第 2 匹配原则是自动转换成更大的基本数据类型，如以下代码：

```
public class OverloadExample {
    public static void main(String[] args) {
        OverloadExample example = new OverloadExample();
        example.method(12);
    }

    public void method(long num) {
        System.out.println("调用 long 方法");
    }

    public void method(Integer num) {
        System.out.println("调用 Integer 方法");
    }

    public void method(Object num) { 
        System.out.println("调用 Object 方法");
    }

    public void method(int... num) { // 可选参数
        System.out.println("调用 int... 方法");
    }
}
```


#### 第3优先级：自动装/拆箱匹配

如果存在基本类型对应的包装类型，或者是包装类型对应的基本类型的方法重载，那么会优先调用自动装箱或自动拆箱的方法重载，如以下代码所示：

```
public class OverloadExample {
    public static void main(String[] args) {
        OverloadExample example = new OverloadExample();
        example.method(12);
    }

    public void method(Integer num) {
        System.out.println("调用 Integer 方法");
    }

    public void method(Object num) {
        System.out.println("调用 Object 方法");
    }

    public void method(int... num) { // 可选参数
        System.out.println("调用 int... 方法");
    }
}
```


#### 第4优先级：按照继承路线依次向上匹配父类

当有父类参数时会优先调用父类重载方法，如下代码所示：

```
public class OverloadExample {
    public static void main(String[] args) {
        OverloadExample example = new OverloadExample();
        example.method(12);
    }

    public void method(Object num) {
        System.out.println("调用 Object 方法");
    }

    public void method(int... num) { // 可选参数
        System.out.println("调用 int... 方法");
    }
}
```


#### 第5优先级：可选参数匹配

可选参数的调用优先级是最低的，当一个类中只有可选参数方法时，才会调用可选参数方法。


## 为什么单例一定要加 volatile

我们在单例模式中使用 volatile，主要是使用 volatile 可以禁止指令重排序，从而保证程序的正常运行。


```java
public class Singleton {
    private Singleton() {}
    // 使用 volatile 禁止指令重排序
    private static volatile Singleton instance = null;
    public static Singleton getInstance() {
        if (instance == null) { // ①
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton(); // ②
                }
            }
        }
        return instance;
    }
}
```

注意观察上述代码，我标记了第 ① 处和第 ② 处的两行代码。给私有变量加 volatile 主要是为了防止第 ② 处执行时，也就是“instance = new Singleton()”执行时的指令重排序的，这行代码看似只是一个创建对象的过程，然而它的实际执行却分为以下 3 步：

创建内存空间。
在内存空间中初始化对象 Singleton。
将内存地址赋值给 instance 对象（执行了此步骤，instance 就不等于 null 了）。
试想一下，如果不加 volatile，那么线程 1 在执行到上述代码的第 ② 处时就可能会执行指令重排序，将原本是 1、2、3 的执行顺序，重排为 1、3、2。但是特殊情况下，线程 1 在执行完第 3 步之后，如果来了线程 2 执行到上述代码的第 ① 处，判断 instance 对象已经不为 null，但此时线程 1 还未将对象实例化完，那么线程 2 将会得到一个被实例化“一半”的对象，从而导致程序执行出错，这就是为什么要给私有变量添加 volatile 的原因了。
