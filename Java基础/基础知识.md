## char 型变量中能存储一个中文汉字吗？

在 Java 中，char 型变量可以存储一个中文汉字。

Java 中的字符采用 Unicode 编码，char 类型占两个字节，而一个汉字在 Unicode 编码中通常也占两个字节，所以 char 类型可以存储一个汉字。

例如：
```java
char c = ‘中’;
System.out.println(c);
```
上述代码会正确输出汉字“中”。


## 枚举能否继承其他类？能否实现接口？

### **1. 枚举能否继承其他类？**

**不能直接继承其他类**，但枚举类本身隐式继承自 `java.lang.Enum`。具体说明如下：



- **隐式继承**：所有枚举类都默认继承自 `java.lang.Enum`，无法显式继承其他类（包括抽象类）。
- **单继承限制**：Java 不支持多重继承，因此枚举不能同时继承 `Enum` 和其他类。



java



运行









```java
// 错误示例：无法显式继承其他类
enum Color extends MyClass {  // 编译错误！
    RED, GREEN, BLUE;
}
```

### **2. 枚举能否实现接口？**

**可以实现接口**，且可以为每个枚举常量提供不同的实现。具体说明如下：



- **实现方式**：枚举类可以实现一个或多个接口。
- **常量级实现**：每个枚举常量可以单独重写接口方法，提供不同的行为。



java



运行









```java
// 接口定义
interface Printable {
    void print();
}

// 枚举实现接口
enum Color implements Printable {
    RED {
        @Override
        public void print() {
            System.out.println("This is red.");
        }
    },
    GREEN {
        @Override
        public void print() {
            System.out.println("This is green.");
        }
    },
    BLUE {
        @Override
        public void print() {
            System.out.println("This is blue.");
        }
    };
}

// 使用示例
Color.RED.print();  // 输出：This is red.
```

```java
public interface Operation {
    double apply(double x, double y);
}

public enum BasicOperation implements Operation {
    PLUS("+") {
        public double apply(double x, double y) { return x + y; }
    },
    MINUS("-") {
        public double apply(double x, double y) { return x - y; }
    },
    TIMES("*") {
        public double apply(double x, double y) { return x * y; }
    },
    DIVIDE("/") {
        public double apply(double x, double y) {
            if (y == 0) throw new ArithmeticException("Cannot divide by zero");
            return x / y;
        }
    };

    private final String symbol;

    BasicOperation(String symbol) {
        this.symbol = symbol;
    }

    public String getSymbol() {
        return symbol;
    }
}
```

### **3. 枚举的其他特性**

- **常量不可变**：枚举常量是单例的，不可实例化新对象。
- **构造器私有**：枚举的构造器必须是私有的（默认隐式私有）。
- **可定义方法和字段**：枚举可以包含方法、字段和构造器。



java



运行









```java
enum Season {
    SPRING("Warm"), SUMMER("Hot"), AUTUMN("Cool"), WINTER("Cold");

    private final String description;

    Season(String description) {  // 构造器默认 private
        this.description = description;
    }

    public String getDescription() {
        return description;
    }
}
```






### **总结**

| **特性**       | **能否实现** | **说明**                                      |
| -------------- | ------------ | --------------------------------------------- |
| 继承其他类     | ? 否         | 隐式继承 `java.lang.Enum`，无法显式继承其他类 |
| 实现接口       | ? 是         | 可以实现多个接口，每个常量可单独重写接口方法  |
| 定义构造器     | ? 是         | 构造器必须为私有，用于初始化枚举常量的属性    |
| 定义方法和字段 | ? 是         | 可以包含静态 / 实例方法、字段                 |

## 反射中如何获取类的所有公共方法和属性？如何获取所有方法和属性（包括私有）？

在 Java 反射中，可以通过以下方式获取类的方法和属性：

**一、获取类的所有公共方法和属性**

1. 获取公共方法：

    - 使用Class类的getMethods()方法可以获取类的所有公共方法，包括从父类继承的方法。该方法返回一个Method数组。

    - 示例代码：

      ```
      import java.lang.reflect.Method;
      
      public class MyClass {
          public void publicMethod() {
              System.out.println("This is a public method.");
          }
      }
      
      public class Main {
          public static void main(String[] args) {
              try {
                  Class<?> clazz = Class.forName("MyClass");
                  Method[] methods = clazz.getMethods();
                  for (Method method : methods) {
                      System.out.println("Method name: " + method.getName());
                  }
              } catch (ClassNotFoundException e) {
                  e.printStackTrace();
              }
          }
      }
      ```



2. 获取公共属性：

    - 使用Class类的getFields()方法可以获取类的所有公共属性，包括从父类继承的属性。该方法返回一个Field数组。

    - 示例代码：

      ```
      import java.lang.reflect.Field;
      
      public class MyClass {
          public int publicField;
      }
      
      public class Main {
          public static void main(String[] args) {
              try {
                  Class<?> clazz = Class.forName("MyClass");
                  Field[] fields = clazz.getFields();
                  for (Field field : fields) {
                      System.out.println("Field name: " + field.getName());
                  }
              } catch (ClassNotFoundException e) {
                  e.printStackTrace();
              }
          }
      }
      ```



**二、获取类的所有方法和属性（包括私有）**

1. 获取所有方法：

    - 使用Class类的getDeclaredMethods()方法可以获取类自身声明的所有方法，包括私有方法。该方法返回一个Method数组。如果要获取包括父类的所有方法，可以结合使用getMethods()和遍历父类的方式。

    - 为了能够访问私有方法，需要使用setAccessible(true)方法来取消访问检查。

    - 示例代码：

      ```
      import java.lang.reflect.Method;
      
      public class MyClass {
          private void privateMethod() {
              System.out.println("This is a private method.");
          }
      }
      
      public class Main {
          public static void main(String[] args) {
              try {
                  Class<?> clazz = Class.forName("MyClass");
                  Method[] methods = clazz.getDeclaredMethods();
                  for (Method method : methods) {
                      method.setAccessible(true);
                      System.out.println("Method name: " + method.getName());
                  }
              } catch (ClassNotFoundException | SecurityException e) {
                  e.printStackTrace();
              }
          }
      }
      ```



2. 获取所有属性：

    - 使用Class类的getDeclaredFields()方法可以获取类自身声明的所有属性，包括私有属性。该方法返回一个Field数组。如果要获取包括父类的所有属性，可以结合使用getFields()和遍历父类的方式。

    - 为了能够访问私有属性，需要使用setAccessible(true)方法来取消访问检查。

    - 示例代码：

      ```
      import java.lang.reflect.Field;
      
      public class MyClass {
          private int privateField;
      }
      
      public class Main {
          public static void main(String[] args) {
              try {
                  Class<?> clazz = Class.forName("MyClass");
                  Field[] fields = clazz.getDeclaredFields();
                  for (Field field : fields) {
                      field.setAccessible(true);
                      System.out.println("Field name: " + field.getName());
                  }
              } catch (ClassNotFoundException | SecurityException e) {
                  e.printStackTrace();
              }
          }
      }
      ```