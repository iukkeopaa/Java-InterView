## char 型变量中能存储一个中文汉字吗？

在 Java 中，char 型变量可以存储一个中文汉字。

Java 中的字符采用 Unicode 编码，char 类型占两个字节，而一个汉字在 Unicode 编码中通常也占两个字节，所以 char 类型可以存储一个汉字。

例如：
```java
char c = ‘中’;
System.out.println(c);
```
上述代码会正确输出汉字“中”。


## 枚举能否继承其他类？能否实现接口？

### **1. 枚举能否继承其他类？**

**不能直接继承其他类**，但枚举类本身隐式继承自 `java.lang.Enum`。具体说明如下：



- **隐式继承**：所有枚举类都默认继承自 `java.lang.Enum`，无法显式继承其他类（包括抽象类）。
- **单继承限制**：Java 不支持多重继承，因此枚举不能同时继承 `Enum` 和其他类。



java



运行









```java
// 错误示例：无法显式继承其他类
enum Color extends MyClass {  // 编译错误！
    RED, GREEN, BLUE;
}
```

### **2. 枚举能否实现接口？**

**可以实现接口**，且可以为每个枚举常量提供不同的实现。具体说明如下：



- **实现方式**：枚举类可以实现一个或多个接口。
- **常量级实现**：每个枚举常量可以单独重写接口方法，提供不同的行为。



java



运行









```java
// 接口定义
interface Printable {
    void print();
}

// 枚举实现接口
enum Color implements Printable {
    RED {
        @Override
        public void print() {
            System.out.println("This is red.");
        }
    },
    GREEN {
        @Override
        public void print() {
            System.out.println("This is green.");
        }
    },
    BLUE {
        @Override
        public void print() {
            System.out.println("This is blue.");
        }
    };
}

// 使用示例
Color.RED.print();  // 输出：This is red.
```

```java
public interface Operation {
    double apply(double x, double y);
}

public enum BasicOperation implements Operation {
    PLUS("+") {
        public double apply(double x, double y) { return x + y; }
    },
    MINUS("-") {
        public double apply(double x, double y) { return x - y; }
    },
    TIMES("*") {
        public double apply(double x, double y) { return x * y; }
    },
    DIVIDE("/") {
        public double apply(double x, double y) {
            if (y == 0) throw new ArithmeticException("Cannot divide by zero");
            return x / y;
        }
    };

    private final String symbol;

    BasicOperation(String symbol) {
        this.symbol = symbol;
    }

    public String getSymbol() {
        return symbol;
    }
}
```

### **3. 枚举的其他特性**

- **常量不可变**：枚举常量是单例的，不可实例化新对象。
- **构造器私有**：枚举的构造器必须是私有的（默认隐式私有）。
- **可定义方法和字段**：枚举可以包含方法、字段和构造器。



java



运行









```java
enum Season {
    SPRING("Warm"), SUMMER("Hot"), AUTUMN("Cool"), WINTER("Cold");

    private final String description;

    Season(String description) {  // 构造器默认 private
        this.description = description;
    }

    public String getDescription() {
        return description;
    }
}
```






### **总结**

| **特性**       | **能否实现** | **说明**                                      |
| -------------- | ------------ | --------------------------------------------- |
| 继承其他类     | ? 否         | 隐式继承 `java.lang.Enum`，无法显式继承其他类 |
| 实现接口       | ? 是         | 可以实现多个接口，每个常量可单独重写接口方法  |
| 定义构造器     | ? 是         | 构造器必须为私有，用于初始化枚举常量的属性    |
| 定义方法和字段 | ? 是         | 可以包含静态 / 实例方法、字段                 |

## 反射中如何获取类的所有公共方法和属性？如何获取所有方法和属性（包括私有）？

在 Java 反射中，可以通过以下方式获取类的方法和属性：

**一、获取类的所有公共方法和属性**

1. 获取公共方法：

    - 使用Class类的getMethods()方法可以获取类的所有公共方法，包括从父类继承的方法。该方法返回一个Method数组。

    - 示例代码：

      ```
      import java.lang.reflect.Method;
      
      public class MyClass {
          public void publicMethod() {
              System.out.println("This is a public method.");
          }
      }
      
      public class Main {
          public static void main(String[] args) {
              try {
                  Class<?> clazz = Class.forName("MyClass");
                  Method[] methods = clazz.getMethods();
                  for (Method method : methods) {
                      System.out.println("Method name: " + method.getName());
                  }
              } catch (ClassNotFoundException e) {
                  e.printStackTrace();
              }
          }
      }
      ```



2. 获取公共属性：

    - 使用Class类的getFields()方法可以获取类的所有公共属性，包括从父类继承的属性。该方法返回一个Field数组。

    - 示例代码：

      ```
      import java.lang.reflect.Field;
      
      public class MyClass {
          public int publicField;
      }
      
      public class Main {
          public static void main(String[] args) {
              try {
                  Class<?> clazz = Class.forName("MyClass");
                  Field[] fields = clazz.getFields();
                  for (Field field : fields) {
                      System.out.println("Field name: " + field.getName());
                  }
              } catch (ClassNotFoundException e) {
                  e.printStackTrace();
              }
          }
      }
      ```



**二、获取类的所有方法和属性（包括私有）**

1. 获取所有方法：

    - 使用Class类的getDeclaredMethods()方法可以获取类自身声明的所有方法，包括私有方法。该方法返回一个Method数组。如果要获取包括父类的所有方法，可以结合使用getMethods()和遍历父类的方式。

    - 为了能够访问私有方法，需要使用setAccessible(true)方法来取消访问检查。

    - 示例代码：

      ```
      import java.lang.reflect.Method;
      
      public class MyClass {
          private void privateMethod() {
              System.out.println("This is a private method.");
          }
      }
      
      public class Main {
          public static void main(String[] args) {
              try {
                  Class<?> clazz = Class.forName("MyClass");
                  Method[] methods = clazz.getDeclaredMethods();
                  for (Method method : methods) {
                      method.setAccessible(true);
                      System.out.println("Method name: " + method.getName());
                  }
              } catch (ClassNotFoundException | SecurityException e) {
                  e.printStackTrace();
              }
          }
      }
      ```



2. 获取所有属性：

    - 使用Class类的getDeclaredFields()方法可以获取类自身声明的所有属性，包括私有属性。该方法返回一个Field数组。如果要获取包括父类的所有属性，可以结合使用getFields()和遍历父类的方式。

    - 为了能够访问私有属性，需要使用setAccessible(true)方法来取消访问检查。

    - 示例代码：

      ```
      import java.lang.reflect.Field;
      
      public class MyClass {
          private int privateField;
      }
      
      public class Main {
          public static void main(String[] args) {
              try {
                  Class<?> clazz = Class.forName("MyClass");
                  Field[] fields = clazz.getDeclaredFields();
                  for (Field field : fields) {
                      field.setAccessible(true);
                      System.out.println("Field name: " + field.getName());
                  }
              } catch (ClassNotFoundException | SecurityException e) {
                  e.printStackTrace();
              }
          }
      }
      ```
      


## 方法优先调用可选参数还是固定参数 固定参数

## 可选参数注意事项

1. 可选参数是从0到无穷
2. 一个方法只能有一个可选参数
3. 可选参数必须要放在方法最后
4. 可选参数和其他同名方法组成方法重载
5. 当程序中有固定参数和可选参数时，优先调用固定参数，而非可选参数。

## 参数匹配过程

#### 第1优先级：精准参数匹配

方法重载会优先调用和方法参数类型一模一样的固定参数方法。

#### 第2优先级：调用基本类型自动转换成更大的基本类型

如果是基本数据类型，那么方法重载调用的第 2 匹配原则是自动转换成更大的基本数据类型，如以下代码：

```
public class OverloadExample {
    public static void main(String[] args) {
        OverloadExample example = new OverloadExample();
        example.method(12);
    }

    public void method(long num) {
        System.out.println("调用 long 方法");
    }

    public void method(Integer num) {
        System.out.println("调用 Integer 方法");
    }

    public void method(Object num) { 
        System.out.println("调用 Object 方法");
    }

    public void method(int... num) { // 可选参数
        System.out.println("调用 int... 方法");
    }
}
```


#### 第3优先级：自动装/拆箱匹配

如果存在基本类型对应的包装类型，或者是包装类型对应的基本类型的方法重载，那么会优先调用自动装箱或自动拆箱的方法重载，如以下代码所示：

```
public class OverloadExample {
    public static void main(String[] args) {
        OverloadExample example = new OverloadExample();
        example.method(12);
    }

    public void method(Integer num) {
        System.out.println("调用 Integer 方法");
    }

    public void method(Object num) {
        System.out.println("调用 Object 方法");
    }

    public void method(int... num) { // 可选参数
        System.out.println("调用 int... 方法");
    }
}
```


#### 第4优先级：按照继承路线依次向上匹配父类

当有父类参数时会优先调用父类重载方法，如下代码所示：

```
public class OverloadExample {
    public static void main(String[] args) {
        OverloadExample example = new OverloadExample();
        example.method(12);
    }

    public void method(Object num) {
        System.out.println("调用 Object 方法");
    }

    public void method(int... num) { // 可选参数
        System.out.println("调用 int... 方法");
    }
}
```


#### 第5优先级：可选参数匹配

可选参数的调用优先级是最低的，当一个类中只有可选参数方法时，才会调用可选参数方法。


## 为什么单例一定要加 volatile

我们在单例模式中使用 volatile，主要是使用 volatile 可以禁止指令重排序，从而保证程序的正常运行。


```java
public class Singleton {
    private Singleton() {}
    // 使用 volatile 禁止指令重排序
    private static volatile Singleton instance = null;
    public static Singleton getInstance() {
        if (instance == null) { // ①
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton(); // ②
                }
            }
        }
        return instance;
    }
}
```

注意观察上述代码，我标记了第 ① 处和第 ② 处的两行代码。给私有变量加 volatile 主要是为了防止第 ② 处执行时，也就是“instance = new Singleton()”执行时的指令重排序的，这行代码看似只是一个创建对象的过程，然而它的实际执行却分为以下 3 步：

创建内存空间。
在内存空间中初始化对象 Singleton。
将内存地址赋值给 instance 对象（执行了此步骤，instance 就不等于 null 了）。
试想一下，如果不加 volatile，那么线程 1 在执行到上述代码的第 ② 处时就可能会执行指令重排序，将原本是 1、2、3 的执行顺序，重排为 1、3、2。但是特殊情况下，线程 1 在执行完第 3 步之后，如果来了线程 2 执行到上述代码的第 ① 处，判断 instance 对象已经不为 null，但此时线程 1 还未将对象实例化完，那么线程 2 将会得到一个被实例化“一半”的对象，从而导致程序执行出错，这就是为什么要给私有变量添加 volatile 的原因了。



## 为什么不同返回类型不算方法重载

#### 1. **编译器无法唯一确定调用的方法**

如果允许 “仅返回类型不同” 的方法作为重载，会导致编译器在解析方法调用时产生歧义。

例如，假设有两个方法：

java











```java
int add(int a, int b) { ... }  // 返回int
void add(int a, int b) { ... } // 返回void
```





![img](data:image/png;base64,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)

当调用 `add(1, 2);` 时，编译器无法确定应该调用哪个方法 ―― 因为调用语句本身没有指定 “需要返回值” 还是 “不需要返回值”（比如调用者可能忽略返回值）。这种歧义会导致编译失败，违背了 “重载需明确区分” 的设计原则。

#### 2. **方法签名的定义规则**

Java 语言规范明确规定：**方法签名由方法名和参数列表组成，与返回类型、访问修饰符、异常列表等无关**。

这意味着：

- 两个方法只要 “方法名相同 + 参数列表相同”，无论返回类型、修饰符等如何不同，都会被视为 “同一个方法”（编译器会报 “方法已定义” 的错误）。
- 只有参数列表不同（数量、类型、顺序），才会被视为不同的方法签名，从而构成重载。

#### 3. **实际调用场景的逻辑矛盾**

在 Java 中，调用方法时可以 “忽略返回值”（例如 `add(1,2);` 不接收返回值）。如果允许仅返回类型不同的重载，这种 “忽略返回值” 的调用方式会彻底破坏重载的确定性。

例如：

java











```java
String getName() { ... }
int getName() { ... }
```

当调用 `getName();` 时，由于没有接收返回值，编译器无法判断应该执行哪个版本的 `getName()`，逻辑上无法成立。

### 总结

方法重载的核心是 “通过参数列表区分不同的方法”，而返回类型无法参与区分（会导致歧义）。因此，仅返回类型不同的方法不符合重载的定义，Java 编译器也会将其视为 “重复定义” 而报错。

## this 和 super 的区别

### 1.指代的对象不同

super 指代的是父类，是用来访问父类的；而 this 指代的是当前类。

### 2.查找范围不同

super 只能查找父类，而 this 会先从本类中找，如果找不到则会去父类中找。

### 3.本类属性赋值不同

this 可以用来为本类的实例属性赋值，而 super 则不能实现此功能。

### 4.this 可用于 synchronized

因为 this 表示当前对象，所以this 可用于 synchronized(this){....} 加锁，而 super 则不能实现此功能。

## 方法重写时需要注意的问题有哪些

### 1. **方法签名必须完全一致**

重写要求子类方法与父类方法的 **方法名、参数列表（数量、类型、顺序）完全相同**。

- 若参数列表不同，则不构成重写，而是 “重载”（子类新增的方法）。
- 若仅方法名相同但参数列表不同，即使父类有该方法，也不算重写。

**示例**：

java



运行









```java
class Parent {
    void print(int num) { ... } // 父类方法：参数为int
}

class Child extends Parent {
    // 正确重写：方法名和参数列表与父类完全一致
    void print(int num) { ... }

    // 不是重写（参数类型不同），而是子类的重载方法
    void print(String str) { ... }
}
```

### 2. **返回类型需兼容（协变返回类型）**

- Java 5 之前：子类重写方法的返回类型必须 **与父类完全相同**。
- Java 5 及之后：允许返回类型是 **父类返回类型的子类**（称为 “协变返回类型”），但不能是更宽泛的类型。

**示例**：

java



运行









```java
class Parent {
    Object getValue() { ... } // 父类返回Object
}

class Child extends Parent {
    // 正确：返回类型是Object的子类（String）
    String getValue() { ... } 

    // 错误：返回类型（Number）不是Object的子类（实际是同级，不兼容）
    Number getValue() { ... } // 编译报错
}
```

### 3. **访问修饰符不能更严格**

子类重写的方法 **访问权限不能比父类更严格**（可以更宽松）。
Java 访问权限从宽到严为：`public > protected > default（包访问） > private`。

- 若父类方法是 `public`，子类必须是 `public`（不能是 `protected` 或 `private`）。
- 若父类方法是 `protected`，子类可以是 `protected` 或 `public`（不能是 `default` 或 `private`）。
- 若父类方法是 `private`，子类无法重写（`private` 方法对子类不可见，子类定义的同名方法视为新方法）。

**示例**：

java



运行









```java
class Parent {
    protected void doSomething() { ... }
}

class Child extends Parent {
    // 正确：访问权限更宽松（public > protected）
    public void doSomething() { ... }

    // 错误：访问权限更严格（default < protected）
    void doSomething() { ... } // 编译报错
}
```

### 4. **异常声明不能更宽泛**

子类重写的方法 **不能抛出比父类更多或更宽泛的 “检查异常”（checked exception）**，但对 “运行时异常”（unchecked exception，如 `NullPointerException`）无限制。

- 允许：不抛异常、抛出父类异常的子类、抛出与父类相同的异常。
- 禁止：抛出父类未声明的更宽泛的检查异常（如父类抛 `IOException`，子类不能抛 `Exception`）。

**示例**：

java



运行









```java
import java.io.IOException;
import java.sql.SQLException;

class Parent {
    void read() throws IOException { ... } // 父类抛IOException（检查异常）
}

class Child extends Parent {
    // 正确：不抛异常
    void read() { ... }

    // 正确：抛父类异常的子类（FileNotFoundException是IOException的子类）
    void read() throws FileNotFoundException { ... }

    // 错误：抛更宽泛的检查异常（Exception包含IOException）
    void read() throws Exception { ... } // 编译报错

    // 正确：运行时异常无限制（NullPointerException是unchecked）
    void read() throws NullPointerException { ... }
}
```

### 5. **静态方法不能被重写（只能被隐藏）**

父类的静态方法（`static`）属于类本身，而非实例，因此 **子类不能重写静态方法**。

- 若子类定义了与父类同名、同参数列表的静态方法，这称为 “隐藏”（hide），而非重写。
- 调用时，静态方法的执行版本由 **引用类型** 决定（而非对象的实际类型），与多态无关。

**示例**：

java



运行









```java
class Parent {
    static void staticMethod() {
        System.out.println("Parent static");
    }
}

class Child extends Parent {
    // 隐藏父类静态方法，不是重写
    static void staticMethod() {
        System.out.println("Child static");
    }
}

// 调用时：看引用类型，不看对象类型
Parent p = new Child();
p.staticMethod(); // 输出 "Parent static"（引用类型是Parent）
Child c = new Child();
c.staticMethod(); // 输出 "Child static"（引用类型是Child）
```

### 6. **final 方法不能被重写**

被 `final` 修饰的方法是 “不可修改的”，父类中用 `final` 修饰的方法，子类 **不能重写**（编译直接报错）。
这是为了保证方法行为的稳定性，防止子类篡改父类的核心逻辑。

**示例**：

java



运行









```java
class Parent {
    final void finalMethod() { ... } // final方法
}

class Child extends Parent {
    // 错误：无法重写final方法
    void finalMethod() { ... } // 编译报错
}
```

### 7. **抽象方法必须被重写（除非子类也是抽象类）**

若父类是抽象类（`abstract`），且包含抽象方法（`abstract`），则：

- 非抽象子类 **必须重写父类所有的抽象方法**（否则编译报错）。
- 若子类也是抽象类，则可以不重写（延迟到更具体的子类实现）。

**示例**：

java



运行









```java
abstract class Parent {
    abstract void abstractMethod(); // 抽象方法
}

// 非抽象子类：必须重写抽象方法
class Child extends Parent {
    @Override
    void abstractMethod() { ... } // 正确
}

// 抽象子类：可以不重写
abstract class AbstractChild extends Parent {
    // 无需重写abstractMethod()，编译通过
}
```

### 8. **遵循里氏替换原则**

重写的方法应保证 **行为与父类兼容**，即子类方法的逻辑应符合父类方法的 “预期功能”，不能彻底改变父类方法的语义。
例如，父类的 `run()` 方法表示 “启动”，子类重写后不应改为 “停止”，否则会导致多态调用时出现逻辑混乱。

### 9. **使用 @Override 注解校验**

虽然不是强制要求，但建议在重写方法上添加 `@Override` 注解。

- 作用：让编译器校验该方法是否真正重写了父类方法（若不符合重写规则，编译时会报错）。
- 避免误写：例如参数列表写错时，编译器会提示 “方法未重写父类方法”。

**示例**：

java



运行









```java
class Child extends Parent {
    @Override // 编译器校验：若参数列表与父类不符，会报错
    void print(int num) { ... }
}
```






### 总结

方法重写的核心规则可概括为：**“签名一致、返回兼容、权限更宽、异常不扩、静态不重、final 不覆”**。遵循这些规则，才能正确实现多态，保证代码的可维护性和逻辑正确性。