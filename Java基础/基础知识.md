## char 型变量中能存储一个中文汉字吗？

在 Java 中，char 型变量可以存储一个中文汉字。

Java 中的字符采用 Unicode 编码，char 类型占两个字节，而一个汉字在 Unicode 编码中通常也占两个字节，所以 char 类型可以存储一个汉字。

例如：
```java
char c = ‘中’;
System.out.println(c);
```
上述代码会正确输出汉字“中”。


## 枚举能否继承其他类？能否实现接口？

### **1. 枚举能否继承其他类？**

**不能直接继承其他类**，但枚举类本身隐式继承自 `java.lang.Enum`。具体说明如下：



- **隐式继承**：所有枚举类都默认继承自 `java.lang.Enum`，无法显式继承其他类（包括抽象类）。
- **单继承限制**：Java 不支持多重继承，因此枚举不能同时继承 `Enum` 和其他类。



java



运行









```java
// 错误示例：无法显式继承其他类
enum Color extends MyClass {  // 编译错误！
    RED, GREEN, BLUE;
}
```

### **2. 枚举能否实现接口？**

**可以实现接口**，且可以为每个枚举常量提供不同的实现。具体说明如下：



- **实现方式**：枚举类可以实现一个或多个接口。
- **常量级实现**：每个枚举常量可以单独重写接口方法，提供不同的行为。



java



运行









```java
// 接口定义
interface Printable {
    void print();
}

// 枚举实现接口
enum Color implements Printable {
    RED {
        @Override
        public void print() {
            System.out.println("This is red.");
        }
    },
    GREEN {
        @Override
        public void print() {
            System.out.println("This is green.");
        }
    },
    BLUE {
        @Override
        public void print() {
            System.out.println("This is blue.");
        }
    };
}

// 使用示例
Color.RED.print();  // 输出：This is red.
```

```java
public interface Operation {
    double apply(double x, double y);
}

public enum BasicOperation implements Operation {
    PLUS("+") {
        public double apply(double x, double y) { return x + y; }
    },
    MINUS("-") {
        public double apply(double x, double y) { return x - y; }
    },
    TIMES("*") {
        public double apply(double x, double y) { return x * y; }
    },
    DIVIDE("/") {
        public double apply(double x, double y) {
            if (y == 0) throw new ArithmeticException("Cannot divide by zero");
            return x / y;
        }
    };

    private final String symbol;

    BasicOperation(String symbol) {
        this.symbol = symbol;
    }

    public String getSymbol() {
        return symbol;
    }
}
```

### **3. 枚举的其他特性**

- **常量不可变**：枚举常量是单例的，不可实例化新对象。
- **构造器私有**：枚举的构造器必须是私有的（默认隐式私有）。
- **可定义方法和字段**：枚举可以包含方法、字段和构造器。



java



运行









```java
enum Season {
    SPRING("Warm"), SUMMER("Hot"), AUTUMN("Cool"), WINTER("Cold");

    private final String description;

    Season(String description) {  // 构造器默认 private
        this.description = description;
    }

    public String getDescription() {
        return description;
    }
}
```






### **总结**

| **特性**       | **能否实现** | **说明**                                      |
| -------------- | ------------ | --------------------------------------------- |
| 继承其他类     | ? 否         | 隐式继承 `java.lang.Enum`，无法显式继承其他类 |
| 实现接口       | ? 是         | 可以实现多个接口，每个常量可单独重写接口方法  |
| 定义构造器     | ? 是         | 构造器必须为私有，用于初始化枚举常量的属性    |
| 定义方法和字段 | ? 是         | 可以包含静态 / 实例方法、字段                 |

## 反射中如何获取类的所有公共方法和属性？如何获取所有方法和属性（包括私有）？

在 Java 反射中，可以通过以下方式获取类的方法和属性：

**一、获取类的所有公共方法和属性**

1. 获取公共方法：

    - 使用Class类的getMethods()方法可以获取类的所有公共方法，包括从父类继承的方法。该方法返回一个Method数组。

    - 示例代码：

      ```
      import java.lang.reflect.Method;
      
      public class MyClass {
          public void publicMethod() {
              System.out.println("This is a public method.");
          }
      }
      
      public class Main {
          public static void main(String[] args) {
              try {
                  Class<?> clazz = Class.forName("MyClass");
                  Method[] methods = clazz.getMethods();
                  for (Method method : methods) {
                      System.out.println("Method name: " + method.getName());
                  }
              } catch (ClassNotFoundException e) {
                  e.printStackTrace();
              }
          }
      }
      ```



2. 获取公共属性：

    - 使用Class类的getFields()方法可以获取类的所有公共属性，包括从父类继承的属性。该方法返回一个Field数组。

    - 示例代码：

      ```
      import java.lang.reflect.Field;
      
      public class MyClass {
          public int publicField;
      }
      
      public class Main {
          public static void main(String[] args) {
              try {
                  Class<?> clazz = Class.forName("MyClass");
                  Field[] fields = clazz.getFields();
                  for (Field field : fields) {
                      System.out.println("Field name: " + field.getName());
                  }
              } catch (ClassNotFoundException e) {
                  e.printStackTrace();
              }
          }
      }
      ```



**二、获取类的所有方法和属性（包括私有）**

1. 获取所有方法：

    - 使用Class类的getDeclaredMethods()方法可以获取类自身声明的所有方法，包括私有方法。该方法返回一个Method数组。如果要获取包括父类的所有方法，可以结合使用getMethods()和遍历父类的方式。

    - 为了能够访问私有方法，需要使用setAccessible(true)方法来取消访问检查。

    - 示例代码：

      ```
      import java.lang.reflect.Method;
      
      public class MyClass {
          private void privateMethod() {
              System.out.println("This is a private method.");
          }
      }
      
      public class Main {
          public static void main(String[] args) {
              try {
                  Class<?> clazz = Class.forName("MyClass");
                  Method[] methods = clazz.getDeclaredMethods();
                  for (Method method : methods) {
                      method.setAccessible(true);
                      System.out.println("Method name: " + method.getName());
                  }
              } catch (ClassNotFoundException | SecurityException e) {
                  e.printStackTrace();
              }
          }
      }
      ```



2. 获取所有属性：

    - 使用Class类的getDeclaredFields()方法可以获取类自身声明的所有属性，包括私有属性。该方法返回一个Field数组。如果要获取包括父类的所有属性，可以结合使用getFields()和遍历父类的方式。

    - 为了能够访问私有属性，需要使用setAccessible(true)方法来取消访问检查。

    - 示例代码：

      ```
      import java.lang.reflect.Field;
      
      public class MyClass {
          private int privateField;
      }
      
      public class Main {
          public static void main(String[] args) {
              try {
                  Class<?> clazz = Class.forName("MyClass");
                  Field[] fields = clazz.getDeclaredFields();
                  for (Field field : fields) {
                      field.setAccessible(true);
                      System.out.println("Field name: " + field.getName());
                  }
              } catch (ClassNotFoundException | SecurityException e) {
                  e.printStackTrace();
              }
          }
      }
      ```
      


## 方法优先调用可选参数还是固定参数 固定参数

## 可选参数注意事项

1. 可选参数是从0到无穷
2. 一个方法只能有一个可选参数
3. 可选参数必须要放在方法最后
4. 可选参数和其他同名方法组成方法重载
5. 当程序中有固定参数和可选参数时，优先调用固定参数，而非可选参数。

## 参数匹配过程

#### 第1优先级：精准参数匹配

方法重载会优先调用和方法参数类型一模一样的固定参数方法。

#### 第2优先级：调用基本类型自动转换成更大的基本类型

如果是基本数据类型，那么方法重载调用的第 2 匹配原则是自动转换成更大的基本数据类型，如以下代码：

```
public class OverloadExample {
    public static void main(String[] args) {
        OverloadExample example = new OverloadExample();
        example.method(12);
    }

    public void method(long num) {
        System.out.println("调用 long 方法");
    }

    public void method(Integer num) {
        System.out.println("调用 Integer 方法");
    }

    public void method(Object num) { 
        System.out.println("调用 Object 方法");
    }

    public void method(int... num) { // 可选参数
        System.out.println("调用 int... 方法");
    }
}
```


#### 第3优先级：自动装/拆箱匹配

如果存在基本类型对应的包装类型，或者是包装类型对应的基本类型的方法重载，那么会优先调用自动装箱或自动拆箱的方法重载，如以下代码所示：

```
public class OverloadExample {
    public static void main(String[] args) {
        OverloadExample example = new OverloadExample();
        example.method(12);
    }

    public void method(Integer num) {
        System.out.println("调用 Integer 方法");
    }

    public void method(Object num) {
        System.out.println("调用 Object 方法");
    }

    public void method(int... num) { // 可选参数
        System.out.println("调用 int... 方法");
    }
}
```


#### 第4优先级：按照继承路线依次向上匹配父类

当有父类参数时会优先调用父类重载方法，如下代码所示：

```
public class OverloadExample {
    public static void main(String[] args) {
        OverloadExample example = new OverloadExample();
        example.method(12);
    }

    public void method(Object num) {
        System.out.println("调用 Object 方法");
    }

    public void method(int... num) { // 可选参数
        System.out.println("调用 int... 方法");
    }
}
```


#### 第5优先级：可选参数匹配

可选参数的调用优先级是最低的，当一个类中只有可选参数方法时，才会调用可选参数方法。


## 为什么单例一定要加 volatile

我们在单例模式中使用 volatile，主要是使用 volatile 可以禁止指令重排序，从而保证程序的正常运行。


```java
public class Singleton {
    private Singleton() {}
    // 使用 volatile 禁止指令重排序
    private static volatile Singleton instance = null;
    public static Singleton getInstance() {
        if (instance == null) { // ①
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton(); // ②
                }
            }
        }
        return instance;
    }
}
```

注意观察上述代码，我标记了第 ① 处和第 ② 处的两行代码。给私有变量加 volatile 主要是为了防止第 ② 处执行时，也就是“instance = new Singleton()”执行时的指令重排序的，这行代码看似只是一个创建对象的过程，然而它的实际执行却分为以下 3 步：

创建内存空间。
在内存空间中初始化对象 Singleton。
将内存地址赋值给 instance 对象（执行了此步骤，instance 就不等于 null 了）。
试想一下，如果不加 volatile，那么线程 1 在执行到上述代码的第 ② 处时就可能会执行指令重排序，将原本是 1、2、3 的执行顺序，重排为 1、3、2。但是特殊情况下，线程 1 在执行完第 3 步之后，如果来了线程 2 执行到上述代码的第 ① 处，判断 instance 对象已经不为 null，但此时线程 1 还未将对象实例化完，那么线程 2 将会得到一个被实例化“一半”的对象，从而导致程序执行出错，这就是为什么要给私有变量添加 volatile 的原因了。



## 为什么不同返回类型不算方法重载

#### 1. **编译器无法唯一确定调用的方法**

如果允许 “仅返回类型不同” 的方法作为重载，会导致编译器在解析方法调用时产生歧义。

例如，假设有两个方法：

java











```java
int add(int a, int b) { ... }  // 返回int
void add(int a, int b) { ... } // 返回void
```





![img](data:image/png;base64,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)

当调用 `add(1, 2);` 时，编译器无法确定应该调用哪个方法 ―― 因为调用语句本身没有指定 “需要返回值” 还是 “不需要返回值”（比如调用者可能忽略返回值）。这种歧义会导致编译失败，违背了 “重载需明确区分” 的设计原则。

#### 2. **方法签名的定义规则**

Java 语言规范明确规定：**方法签名由方法名和参数列表组成，与返回类型、访问修饰符、异常列表等无关**。

这意味着：

- 两个方法只要 “方法名相同 + 参数列表相同”，无论返回类型、修饰符等如何不同，都会被视为 “同一个方法”（编译器会报 “方法已定义” 的错误）。
- 只有参数列表不同（数量、类型、顺序），才会被视为不同的方法签名，从而构成重载。

#### 3. **实际调用场景的逻辑矛盾**

在 Java 中，调用方法时可以 “忽略返回值”（例如 `add(1,2);` 不接收返回值）。如果允许仅返回类型不同的重载，这种 “忽略返回值” 的调用方式会彻底破坏重载的确定性。

例如：

java











```java
String getName() { ... }
int getName() { ... }
```

当调用 `getName();` 时，由于没有接收返回值，编译器无法判断应该执行哪个版本的 `getName()`，逻辑上无法成立。

### 总结

方法重载的核心是 “通过参数列表区分不同的方法”，而返回类型无法参与区分（会导致歧义）。因此，仅返回类型不同的方法不符合重载的定义，Java 编译器也会将其视为 “重复定义” 而报错。

## this 和 super 的区别

### 1.指代的对象不同

super 指代的是父类，是用来访问父类的；而 this 指代的是当前类。

### 2.查找范围不同

super 只能查找父类，而 this 会先从本类中找，如果找不到则会去父类中找。

### 3.本类属性赋值不同

this 可以用来为本类的实例属性赋值，而 super 则不能实现此功能。

### 4.this 可用于 synchronized

因为 this 表示当前对象，所以this 可用于 synchronized(this){....} 加锁，而 super 则不能实现此功能。

## 方法重写时需要注意的问题有哪些

### 1. **方法签名必须完全一致**

重写要求子类方法与父类方法的 **方法名、参数列表（数量、类型、顺序）完全相同**。

- 若参数列表不同，则不构成重写，而是 “重载”（子类新增的方法）。
- 若仅方法名相同但参数列表不同，即使父类有该方法，也不算重写。

**示例**：

java



运行









```java
class Parent {
    void print(int num) { ... } // 父类方法：参数为int
}

class Child extends Parent {
    // 正确重写：方法名和参数列表与父类完全一致
    void print(int num) { ... }

    // 不是重写（参数类型不同），而是子类的重载方法
    void print(String str) { ... }
}
```

### 2. **返回类型需兼容（协变返回类型）**

- Java 5 之前：子类重写方法的返回类型必须 **与父类完全相同**。
- Java 5 及之后：允许返回类型是 **父类返回类型的子类**（称为 “协变返回类型”），但不能是更宽泛的类型。

**示例**：

java



运行









```java
class Parent {
    Object getValue() { ... } // 父类返回Object
}

class Child extends Parent {
    // 正确：返回类型是Object的子类（String）
    String getValue() { ... } 

    // 错误：返回类型（Number）不是Object的子类（实际是同级，不兼容）
    Number getValue() { ... } // 编译报错
}
```

### 3. **访问修饰符不能更严格**

子类重写的方法 **访问权限不能比父类更严格**（可以更宽松）。
Java 访问权限从宽到严为：`public > protected > default（包访问） > private`。

- 若父类方法是 `public`，子类必须是 `public`（不能是 `protected` 或 `private`）。
- 若父类方法是 `protected`，子类可以是 `protected` 或 `public`（不能是 `default` 或 `private`）。
- 若父类方法是 `private`，子类无法重写（`private` 方法对子类不可见，子类定义的同名方法视为新方法）。

**示例**：

java



运行









```java
class Parent {
    protected void doSomething() { ... }
}

class Child extends Parent {
    // 正确：访问权限更宽松（public > protected）
    public void doSomething() { ... }

    // 错误：访问权限更严格（default < protected）
    void doSomething() { ... } // 编译报错
}
```

### 4. **异常声明不能更宽泛**

子类重写的方法 **不能抛出比父类更多或更宽泛的 “检查异常”（checked exception）**，但对 “运行时异常”（unchecked exception，如 `NullPointerException`）无限制。

- 允许：不抛异常、抛出父类异常的子类、抛出与父类相同的异常。
- 禁止：抛出父类未声明的更宽泛的检查异常（如父类抛 `IOException`，子类不能抛 `Exception`）。

**示例**：

java



运行









```java
import java.io.IOException;
import java.sql.SQLException;

class Parent {
    void read() throws IOException { ... } // 父类抛IOException（检查异常）
}

class Child extends Parent {
    // 正确：不抛异常
    void read() { ... }

    // 正确：抛父类异常的子类（FileNotFoundException是IOException的子类）
    void read() throws FileNotFoundException { ... }

    // 错误：抛更宽泛的检查异常（Exception包含IOException）
    void read() throws Exception { ... } // 编译报错

    // 正确：运行时异常无限制（NullPointerException是unchecked）
    void read() throws NullPointerException { ... }
}
```

### 5. **静态方法不能被重写（只能被隐藏）**

父类的静态方法（`static`）属于类本身，而非实例，因此 **子类不能重写静态方法**。

- 若子类定义了与父类同名、同参数列表的静态方法，这称为 “隐藏”（hide），而非重写。
- 调用时，静态方法的执行版本由 **引用类型** 决定（而非对象的实际类型），与多态无关。

**示例**：

java



运行









```java
class Parent {
    static void staticMethod() {
        System.out.println("Parent static");
    }
}

class Child extends Parent {
    // 隐藏父类静态方法，不是重写
    static void staticMethod() {
        System.out.println("Child static");
    }
}

// 调用时：看引用类型，不看对象类型
Parent p = new Child();
p.staticMethod(); // 输出 "Parent static"（引用类型是Parent）
Child c = new Child();
c.staticMethod(); // 输出 "Child static"（引用类型是Child）
```

### 6. **final 方法不能被重写**

被 `final` 修饰的方法是 “不可修改的”，父类中用 `final` 修饰的方法，子类 **不能重写**（编译直接报错）。
这是为了保证方法行为的稳定性，防止子类篡改父类的核心逻辑。

**示例**：

java



运行









```java
class Parent {
    final void finalMethod() { ... } // final方法
}

class Child extends Parent {
    // 错误：无法重写final方法
    void finalMethod() { ... } // 编译报错
}
```

### 7. **抽象方法必须被重写（除非子类也是抽象类）**

若父类是抽象类（`abstract`），且包含抽象方法（`abstract`），则：

- 非抽象子类 **必须重写父类所有的抽象方法**（否则编译报错）。
- 若子类也是抽象类，则可以不重写（延迟到更具体的子类实现）。

**示例**：

java



运行









```java
abstract class Parent {
    abstract void abstractMethod(); // 抽象方法
}

// 非抽象子类：必须重写抽象方法
class Child extends Parent {
    @Override
    void abstractMethod() { ... } // 正确
}

// 抽象子类：可以不重写
abstract class AbstractChild extends Parent {
    // 无需重写abstractMethod()，编译通过
}
```

### 8. **遵循里氏替换原则**

重写的方法应保证 **行为与父类兼容**，即子类方法的逻辑应符合父类方法的 “预期功能”，不能彻底改变父类方法的语义。
例如，父类的 `run()` 方法表示 “启动”，子类重写后不应改为 “停止”，否则会导致多态调用时出现逻辑混乱。

### 9. **使用 @Override 注解校验**

虽然不是强制要求，但建议在重写方法上添加 `@Override` 注解。

- 作用：让编译器校验该方法是否真正重写了父类方法（若不符合重写规则，编译时会报错）。
- 避免误写：例如参数列表写错时，编译器会提示 “方法未重写父类方法”。

**示例**：

java



运行









```java
class Child extends Parent {
    @Override // 编译器校验：若参数列表与父类不符，会报错
    void print(int num) { ... }
}
```






### 总结

方法重写的核心规则可概括为：**“签名一致、返回兼容、权限更宽、异常不扩、静态不重、final 不覆”**。遵循这些规则，才能正确实现多态，保证代码的可维护性和逻辑正确性。


## 解析Java多态的底层实现机制

Java多态的实现基于方法的动态绑定机制，它允许一个引用变量在运行时绑定到多种不同的类型。多态的实现主要依赖于Java虚拟机（JVM）在方法调用时选择正确版本的动态查找过程。

**1、编译时多态：** 通过方法重载实现，依赖于方法的签名（方法名和参数类型）来选择调用哪个方法。

**2、运行时多态：** 主要通过方法覆盖实现，依赖于对象的实际类型。JVM使用对象的实际类信息和方法表（vtable）来确定应该调用哪个方法。


## 讲述Java中的动态绑定和静态绑定

Java中的动态绑定和静态绑定：

**1、静态绑定：** 发生在编译时，适用于私有方法、静态方法、final方法或构造方法。编译器使用类型信息进行绑定。

**2、动态绑定：** 发生在运行时，适用于通过多态方式调用的方法。JVM根据对象的实际类型确定要调用的方法。

动态绑定使得Java的多态成为可能，增加了程序的灵活性和可扩展性。

## 代码块的初始化执行顺序

### **一、基础概念：3 种初始化代码块**

1. **静态代码块（static block）**
   - 格式：`static { ... }`
   - 属于**类级别**，随类的加载而执行，**仅执行一次**（无论创建多少对象）。
   - 作用：初始化静态变量（类变量），或执行类加载时的前置逻辑（如注册驱动）。
2. **实例代码块（instance block）**
   - 格式：`{ ... }`（无 static 修饰）
   - 属于**对象级别**，每次创建对象时执行，在构造器之前运行。
   - 作用：初始化实例变量，或抽取多个构造器的公共逻辑（减少代码冗余）。
3. **构造器（constructor）**
   - 格式：`类名(参数) { ... }`
   - 属于**对象级别**，每次创建对象时执行，用于对象的最终初始化（如参数校验、复杂逻辑）。

### **二、无继承关系时的执行顺序**

在单个类中，初始化顺序为：
**静态代码块 → 实例代码块 → 构造器**

#### 示例代码：

java



运行









```java
public class InitialOrder {
    // 静态变量
    private static int staticVar = 10;
    // 实例变量
    private int instanceVar = 20;

    // 静态代码块1
    static {
        System.out.println("静态代码块1：staticVar = " + staticVar);
        staticVar = 100; // 修改静态变量
    }

    // 实例代码块1
    {
        System.out.println("实例代码块1：instanceVar = " + instanceVar);
        instanceVar = 200; // 修改实例变量
    }

    // 构造器
    public InitialOrder() {
        System.out.println("构造器：instanceVar = " + instanceVar + "，staticVar = " + staticVar);
    }

    // 静态代码块2（多个静态代码块按出现顺序执行）
    static {
        System.out.println("静态代码块2：staticVar = " + staticVar);
    }

    // 实例代码块2（多个实例代码块按出现顺序执行）
    {
        System.out.println("实例代码块2：instanceVar = " + instanceVar);
    }

    public static void main(String[] args) {
        System.out.println("--- 第一次创建对象 ---");
        new InitialOrder();
        System.out.println("--- 第二次创建对象 ---");
        new InitialOrder();
    }
}
```

#### 输出结果：

plaintext











```plaintext
静态代码块1：staticVar = 10
静态代码块2：staticVar = 100
--- 第一次创建对象 ---
实例代码块1：instanceVar = 20
实例代码块2：instanceVar = 200
构造器：instanceVar = 200，staticVar = 100
--- 第二次创建对象 ---
实例代码块1：instanceVar = 20
实例代码块2：instanceVar = 200
构造器：instanceVar = 200，staticVar = 100
```

#### 结论：

- 静态代码块**只执行一次**（类加载时），多个静态代码块按**代码出现顺序**执行。
- 实例代码块和构造器**每次创建对象都执行**，实例代码块在构造器前执行，多个实例代码块按**代码出现顺序**执行。

### **三、有继承关系时的执行顺序**

当存在父子类继承时，初始化顺序需叠加 “**父类优先于子类**” 的规则，完整顺序为：
**父类静态代码块 → 子类静态代码块 → 父类实例代码块 → 父类构造器 → 子类实例代码块 → 子类构造器**

#### 示例代码（继承关系）：

java



运行









```java
// 父类
class Parent {
    static {
        System.out.println("父类静态代码块");
    }

    {
        System.out.println("父类实例代码块");
    }

    public Parent() {
        System.out.println("父类构造器");
    }
}

// 子类
class Child extends Parent {
    static {
        System.out.println("子类静态代码块");
    }

    {
        System.out.println("子类实例代码块");
    }

    public Child() {
        System.out.println("子类构造器");
    }

    public static void main(String[] args) {
        System.out.println("--- 创建子类对象 ---");
        new Child();
    }
}
```

#### 输出结果：

plaintext











```plaintext
父类静态代码块  // 父类加载时执行
子类静态代码块  // 子类加载时执行（类加载：先父后子）
--- 创建子类对象 ---
父类实例代码块  // 父类对象初始化
父类构造器      // 父类构造器执行
子类实例代码块  // 子类对象初始化
子类构造器      // 子类构造器执行
```

#### 关键原因：

1. **类加载阶段**：JVM 加载类时，先加载父类（Object 为根），再加载子类，因此静态代码块执行顺序为 “父类→子类”。
2. **对象创建阶段**：创建子类对象时，必须先完成父类的初始化（通过`super()`隐式调用父类构造器），因此实例代码块和构造器的顺序为 “父类实例代码块→父类构造器→子类实例代码块→子类构造器”。

### **四、特殊情况：变量初始化与代码块的交织**

静态变量、实例变量的初始化与代码块的执行顺序遵循 “**按代码出现顺序执行**” 的规则。

#### 示例（静态变量与静态代码块）：

java



运行









```java
public class VarAndBlock {
    // 静态变量1
    private static int a = 1;

    static {
        System.out.println("静态代码块：a = " + a); // 输出1
        a = 2; // 修改a
    }

    // 静态变量2（在静态代码块之后定义）
    private static int b = a + 1;

    public static void main(String[] args) {
        System.out.println("b = " + b); // 输出3（a已被改为2）
    }
}
```



**输出**：



plaintext











```plaintext
静态代码块：a = 1  
b = 3  
```



**原因**：静态变量和静态代码块按在类中定义的顺序依次执行（先初始化`a=1`，再执行静态代码块修改`a=2`，最后初始化`b=a+1=3`）。

### **五、总结：初始化执行总规则**

1. **类加载阶段**（只执行一次）：
   父类静态变量初始化 → 父类静态代码块 → 子类静态变量初始化 → 子类静态代码块
2. **对象创建阶段**（每次 new 对象执行）：
   父类实例变量初始化 → 父类实例代码块 → 父类构造器 → 子类实例变量初始化 → 子类实例代码块 → 子类构造器



记忆口诀：**“静父先于静子，实父先于实子，块先于构造”**。


## 一个父类加载器能不能加载一个子类加载器，为什么?

### 1. 类加载器本身也是 Java 类

所有自定义类加载器（包括 JDK 提供的`Extension ClassLoader`、`Application ClassLoader`等）本质上都是`java.lang.ClassLoader`的子类，它们自身也是 Java 类，需要被其他类加载器加载后才能运行。



例如：



- `Application ClassLoader`（应用类加载器）通常由`Extension ClassLoader`（扩展类加载器）加载；
- 自定义的`MyClassLoader`（作为子类加载器）可能由`Application ClassLoader`（作为其父加载器）加载。

### 2. 双亲委派模型的 “父子” 是逻辑委派关系，而非物理继承限制

Java 类加载器的 “父子关系” 并非面向对象中的`extends`继承关系，而是**逻辑上的委派关系**：每个类加载器都有一个 “父加载器”（通过`getParent()`方法获取），用于在加载类时优先委派父加载器尝试加载。



这种关系是通过 “组合” 实现的（子加载器内部持有父加载器的引用），而非继承。因此，父加载器加载子加载器类，与 “子加载器将父加载器作为委派对象” 之间没有冲突。

### 3. 加载的核心是 “类路径可见性”

类加载器加载类的前提是：待加载的类的字节码（`.class`文件）在该加载器的**搜索路径范围内**。



如果子类加载器的类（例如`MyClassLoader.class`）存在于父加载器的搜索路径中（比如放在`JRE/lib/ext`目录下，属于`Extension ClassLoader`的搜索范围），那么父加载器会按照双亲委派的规则（先尝试自己加载）成功加载该子类加载器。

### 4. 典型案例：JDK 类加载器的加载过程

JDK 中的类加载器本身的加载过程就是 “父加载器加载子加载器” 的典型例子：



- `Bootstrap ClassLoader`（启动类加载器，由原生代码实现，非 Java 类）是最顶层的加载器，它会加载`Extension ClassLoader`的类（`sun.misc.Launcher$ExtClassLoader`）；
- `Extension ClassLoader`会加载`Application ClassLoader`的类（`sun.misc.Launcher$AppClassLoader`）；
- 后续的自定义类加载器，通常由`Application ClassLoader`加载。

### 总结

父类加载器可以加载子类加载器，原因是：



- 子类加载器本身是 Java 类，需要被其他加载器加载才能运行；
- 类加载器的 “父子” 是逻辑委派关系（组合），而非继承，不限制父加载器加载子加载器类；
- 只要子类加载器的字节码在父加载器的搜索路径中，父加载器就可以正常加载它。


## HashMap 的 table 数组容量为什么总是 2 的幂？如果不是会发生什么

HashMap 的 table 数组容量之所以总是 2 的幂，主要是为了保证元素在数组中分布均匀，减少哈希冲突，提升性能。具体原因如下：

1. **取模运算优化**：当数组长度是 2 的幂时，计算元素位置的模运算可以转化为位运算（hash & (length-1)），这比直接取模（%）效率更高。
2. **均匀分布元素**：2 的幂长度能使哈希值的高位和低位都参与位置计算，减少哈希冲突。如果长度不是 2 的幂，可能会导致某些位置永远不会被使用。
3. **扩容机制配合**：HashMap 扩容时容量翻倍（仍为 2 的幂），这种设计使得在扩容后重新计算元素位置时，只需判断哈希值的某一位是 0 还是 1，避免了重新计算整个哈希值。

如果容量不是 2 的幂，会出现以下问题：

- **哈希冲突增加**：元素分布不均匀，部分位置频繁冲突，导致链表或红黑树过长，降低查询效率。
- **性能下降**：无法使用高效的位运算替代取模，影响插入和查找操作的速度。
- **空间浪费**：数组某些位置可能永远不会被使用，造成空间浪费。

HashMap 在初始化时会自动将初始容量调整为大于等于该值的最小 2 的幂。例如，若指定初始容量为 10，HashMap 会将其调整为 16。这一机制确保了 HashMap 的 table 数组容量始终为 2 的幂，从而维持高效的哈希分布和操作性能。


## hashmap中哈希函数是怎么设定的

HashMap 中的哈希函数设计旨在尽可能减少哈希冲突，使元素均匀分布在数组中。以 Java 8 的 HashMap 为例，其哈希函数的实现分为两个关键步骤：

1. **计算原始哈希值**：调用键对象的`hashCode()`方法获取原始哈希码。
2. **扰动函数处理**：将原始哈希码的高位与低位进行异或运算，增强低位的随机性。

### 源码实现

Java 8 中 HashMap 的哈希函数实现如下：

java



运行









```java
static final int hash(Object key) {
    int h;
    // key.hashCode() 获取原始哈希码
    // (h >>> 16) 将哈希码右移16位，高16位变为低16位，高16位补0
    // ^ 异或运算，将高位特征与低位混合
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

### 设计原理

1. **扰动函数的作用**：
   - HashMap 的数组长度通常较小（如 16、32），直接用原始哈希码与数组长度取模时，只有低位参与计算，高位信息被丢弃。
   - 通过将哈希码的高 16 位与低 16 位异或（`h ^ (h >>> 16)`），让高位信息也参与到位置计算中，减少哈希冲突。
2. **示例说明**：
   - 假设原始哈希码为：`0b 11001010 01101111 00110101 10101100`
   - 右移 16 位后：`0b 00000000 00000000 11001010 01101111`
   - 异或结果：`0b 11001010 01101111 11111111 11000011`
   - 最终用这个混合后的哈希值与数组长度取模，低位包含了更多高位的特征。
3. **性能与冲突的平衡**：
   - 只进行一次异或运算，在性能和冲突减少之间取得平衡。
   - 实验证明，这种简单的扰动函数在大多数场景下能有效减少冲突。

### 与数组长度的配合

当数组长度为 2 的幂时，计算元素位置的公式为：`(length - 1) & hash`。例如：

- 数组长度为 16（二进制`0b10000`），`length - 1`为 15（二进制`0b1111`）。
- 哈希值与`0b1111`按位与，直接截取低位的 4 位作为数组索引，范围正好是 0~15。

这种设计结合扰动函数，使得哈希值的高位和低位都参与到索引计算中，有效减少了哈希冲突。


## HashMap 扩容时为什么需要复制所有元素我能不能用链表挂接新 table 来避免复制

在 HashMap 扩容时，不能简单地用链表挂接新 table 来避免元素复制，主要原因在于**哈希值与数组长度的映射关系发生了变化**。具体分析如下：

### 1. **扩容的本质：重新计算索引位置**

HashMap 的索引计算公式为：`index = hash & (table.length - 1)`。
当数组长度（`table.length`）扩容为原来的 2 倍时，`length - 1`的二进制掩码会多一位（例如从`00001111`变为`00011111`），导致**元素的索引位置可能发生变化**。

**示例**：

- 原数组长度 16（掩码`0b1111`），某元素`hash = 27`（二进制`0b00011011`），索引为`27 & 15 = 11`。
- 扩容后长度 32（掩码`0b11111`），索引变为`27 & 31 = 27`，位置发生变化。

因此，扩容后元素需要根据新的掩码重新计算位置，无法直接复用原链表结构。

### 2. **链表挂接新 table 的问题**

如果直接将原链表挂接到新 table，会导致以下问题：

- **索引错误**：新 table 的长度变化，原链表中元素的索引可能不再正确。例如，原链表中索引为 11 的元素，在新 table 中可能需要放到索引 27 的位置。
- **数据混乱**：多个元素可能被错误地挂接到同一索引下，破坏哈希表的结构，导致查询、插入失败。

### 3. **Java HashMap 的扩容优化**

虽然需要复制元素，但 Java 8 的 HashMap 通过**链表拆分算法**减少了复制开销：

- **原理**：扩容后，原链表中的元素会被拆分为两个链表（`lo链`和`hi链`），分别对应扩容后索引不变和需要移动的元素。
- **拆分规则**：
  若`hash & oldCapacity == 0`，元素留在原索引（`lo链`）；
  否则元素移动到`原索引 + oldCapacity`（`hi链`）。

**示例**：

- 原数组长度 16（`oldCapacity = 16`，二进制`0b10000`）。
- 某元素`hash = 27`（`0b00011011`），`27 & 16 = 16 ≠ 0`，则在新 table 中移动到`11 + 16 = 27`。

这种优化避免了逐个重新计算哈希值，而是通过一次位运算直接拆分链表，时间复杂度从 O (n?logn) 降至 O (n)。

### 4. **为什么不能用指针 / 引用替代复制？**

- **内存布局限制**：Java 对象的引用无法直接指向其他对象的内部字段（如链表节点的`next`指针），必须通过复制节点对象来重建链表。
- **并发安全问题**：若多个线程同时操作原链表和新链表，可能导致循环引用或数据丢失（如 HashMap 在多线程下的`resize()`死循环问题）。

### 总结

HashMap 扩容时必须复制元素的根本原因是：**数组长度变化导致哈希映射关系改变**。虽然复制操作有开销，但通过链表拆分算法，Java 已经将时间复杂度优化到 O (n)，这是在哈希表结构下的最优解。若想避免复制，需采用其他数据结构（如跳表、并发哈希表），但这会引入额外的复杂度。