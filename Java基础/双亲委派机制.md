双亲委派模型（Parents Delegation Model）是 Java 类加载器的基本工作机制，其核心原则是：当一个类加载器收到类加载请求时，它首先会委托给父类加载器尝试加载，只有当父类加载器无法加载时，才会自己尝试加载。这种机制保证了类的唯一性和安全性，但在某些特殊场景下，我们需要打破这一模型。以下是几种典型情况：

### **1. 热部署 / 热替换需求**

- **场景**：在开发或生产环境中，需要在不重启应用的情况下更新类文件（如插件系统、代码热修复）。
- **问题**：双亲委派模型下，类加载器会优先使用已加载的类，即使类文件已更新。
- **解决方案**：自定义类加载器，使其直接加载新版本的类，而不委派给父类加载器。例如，OSGi 框架通过自定义类加载器实现模块的动态更新。

### **2. 类路径隔离需求**

- **场景**：多个模块或框架依赖同一类的不同版本（如 Servlet 容器、应用服务器）。

- **问题**：双亲委派模型保证类的唯一性，导致不同版本的类无法共存。

- 解决方案

  ：自定义类加载器，打破委派规则，强制特定类由当前类加载器加载。例如：

    - Tomcat 的 WebappClassLoader 为每个 Web 应用创建独立的类加载器，实现类的隔离。
    - Maven Shade Plugin 通过重命名类和资源解决依赖冲突。

### **3. 加载非标准位置的类**

- **场景**：从网络、数据库或加密文件中加载类，或加载自定义格式的类（如 Android 的 DexClassLoader）。
- **问题**：父类加载器通常只能从标准路径（如 classpath、jar 文件）加载类。
- **解决方案**：自定义类加载器，直接实现类的加载逻辑，不依赖父类加载器。

### **4. 特殊系统类的重写**

- **场景**：需要替换 JDK 核心类的实现（如自定义 `java.lang.String`）。
- **问题**：双亲委派模型下，核心类由 Bootstrap ClassLoader 加载，用户自定义的同名类无法被加载。
- **解决方案**：在 JVM 启动参数中使用 `-Xbootclasspath/p` 参数，或自定义类加载器绕过委派机制（需谨慎，可能破坏 JVM 稳定性）。

### **5. 框架需要优先加载自定义类**

- **场景**：框架需要优先加载自身提供的类，而非 JDK 或父类加载器中的类。

- 典型案例

  ：

    - **JDBC 驱动加载**：JDBC 4.0 之前通过 `DriverManager.registerDriver()` 手动注册驱动，打破双亲委派以加载具体数据库厂商的驱动类。
    - **SPI（Service Provider Interface）机制**：如 Java 的 `java.util.ServiceLoader` 允许从 classpath 加载实现类，需通过线程上下文类加载器（Thread Context ClassLoader）实现逆向委派。

### **6. 安全性和沙箱环境需求**

- **场景**：创建安全的沙箱环境（如 Applet、代码审计工具），限制某些类的加载范围。
- **解决方案**：自定义类加载器，通过权限检查或白名单机制控制类的加载，确保安全隔离。

### **典型案例：打破双亲委派的实现**

#### **1. Tomcat 的类加载架构**

Tomcat 为每个 Web 应用创建独立的 `WebappClassLoader`，其加载顺序为：

1. 加载 Web 应用自身的类（WEB-INF/classes 和 WEB-INF/lib）。
2. 委派给父类加载器（Common ClassLoader）。
   这种模式允许不同 Web 应用使用同一类的不同版本。

#### **2. OSGi 动态模块系统**

OSGi 框架通过自定义类加载器实现模块间的类隔离和动态加载，每个模块可以指定导出和导入的包，打破了传统的双亲委派层级。

#### **3. JDBC 驱动加载**

JDBC 驱动的加载通过线程上下文类加载器实现：

java



运行









```java
// 线程上下文类加载器允许子加载器反向委派给父加载器
Connection conn = DriverManager.getConnection(url, username, password);
```

### **总结**

双亲委派模型的核心优势是类的唯一性和安全性，但在动态性、隔离性和兼容性要求较高的场景下，需要打破这一模型。打破双亲委派通常通过自定义类加载器，重写 `loadClass()` 方法，改变类加载的顺序或逻辑。但这种做法需谨慎使用，可能引入类冲突、内存泄漏等问题。