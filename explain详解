在 MySQL 中，`EXPLAIN` 是一个强大的分析工具，用于查看 SQL 查询的执行计划（Execution Plan）。通过它可以了解数据库如何执行查询，包括表的读取顺序、索引使用情况、数据过滤方式等，从而优化查询性能。

### **一、基本语法**

sql











```sql
EXPLAIN SELECT ...;  -- 用于SELECT语句
EXPLAIN DELETE ...;  -- 用于DELETE语句
EXPLAIN INSERT ...;  -- 用于INSERT语句
EXPLAIN UPDATE ...;  -- 用于UPDATE语句
```



**示例：**



sql











```sql
EXPLAIN SELECT * FROM users WHERE age > 18;
```

### **二、输出字段详解**

`EXPLAIN` 的输出通常包含以下关键列：

#### 1. **id**

- **含义**：查询的标识符，标识执行顺序（数字越大越先执行；相同数字按从上到下顺序执行）。

- 示例

  ：

  plaintext

  

  

  

  

  

  ```plaintext
  +----+-------------+-------+
  | id | select_type | table |
  +----+-------------+-------+
  | 1  | PRIMARY     | users |
  | 2  | SUBQUERY    | ...   |
  +----+-------------+-------+
  ```

#### 2. **select_type**

- 含义

  ：查询类型，常见值：

  - `SIMPLE`：简单查询（无子查询或 UNION）。
  - `PRIMARY`：主查询（包含子查询的外层查询）。
  - `SUBQUERY`：子查询。
  - `DERIVED`：派生表（FROM 子句中的子查询）。

#### 3. **table**

- **含义**：当前执行的表名（或别名）。

#### 4. **type**

- 含义

  ：连接类型，反映查询效率（从最优到最差）：

  - `system`/`const`：表只有一行数据，或通过主键 / 唯一索引直接匹配。
  - `eq_ref`：使用唯一索引（如主键）进行连接，每行仅匹配一条记录。
  - `ref`：使用非唯一索引或索引前缀匹配。
  - `range`：使用索引进行范围扫描（如`WHERE age > 18`）。
  - `index`：全索引扫描（遍历索引树）。
  - `ALL`：全表扫描（性能最差）。

#### 5. **possible_keys**

- **含义**：可能使用的索引。

#### 6. **key**

- **含义**：实际使用的索引。若为`NULL`，表示未使用索引。

#### 7. **key_len**

- **含义**：索引使用的字节数，反映索引的精确程度（值越小越精确）。

#### 8. **ref**

- **含义**：哪些列或常量用于与索引比较。

#### 9. **rows**

- **含义**：MySQL 估算需要扫描的行数（值越小性能越好）。

#### 10. **Extra**

- 含义

  ：额外信息，常见值：

  - `Using index`：使用覆盖索引（无需回表）。
  - `Using where`：使用 WHERE 子句过滤数据。
  - `Using temporary`：使用临时表（如 GROUP BY 或 ORDER BY）。
  - `Using filesort`：使用文件排序（性能较差）。

### **三、执行计划示例**

**查询：**



sql











```sql
EXPLAIN SELECT * FROM users 
JOIN orders ON users.id = orders.user_id 
WHERE users.age > 18 AND orders.status = 'paid';
```



**输出：**



plaintext











```plaintext
+----+-------------+-------+-------+---------------+---------+---------+----------------+--------+-------------+
| id | select_type | table | type  | possible_keys | key     | key_len | ref            | rows   | Extra       |
+----+-------------+-------+-------+---------------+---------+---------+----------------+--------+-------------+
| 1  | SIMPLE      | users | range | age_idx       | age_idx | 4       | NULL           | 1000   | Using where |
| 1  | SIMPLE      | orders| ref   | user_id_idx   | user_id_idx| 4     | users.id       | 5      | Using where |
+----+-------------+-------+-------+---------------+---------+---------+----------------+--------+-------------+
```



**分析：**



1. `users`表通过`age_idx`索引进行范围扫描（`type=range`），估算扫描 1000 行。
2. `orders`表通过`user_id_idx`索引与`users`表连接（`type=ref`），每行匹配 5 条记录。

### **四、性能优化建议**

1. **避免全表扫描（`type=ALL`）**

   - 为`WHERE`条件字段添加索引。

   - 示例：

     sql

     

     

     

     

     

     ```sql
     ALTER TABLE users ADD INDEX age_idx (age);
     ```

2. **减少临时表和文件排序**

   - 优化`GROUP BY`/`ORDER BY`字段，确保使用索引。

   - 示例：

     sql

     

     

     

     

     

     ```sql
     SELECT user_id, COUNT(*) FROM orders GROUP BY user_id;  -- 确保user_id有索引
     ```

3. **使用覆盖索引（`Using index`）**

   - 让索引包含所有需要查询的字段，避免回表。

   - 示例：

     sql

     

     

     

     

     

     ```sql
     SELECT user_id, order_id FROM orders WHERE status = 'paid';  -- 为(status, user_id, order_id)创建复合索引
     ```

     

     


4. **优化子查询**

   - 将子查询转换为`JOIN`，避免`DERIVED`类型的临时表。

### **五、注意事项**

1. `EXPLAIN`显示的是**估算数据**，实际执行可能不同（如统计信息过时）。
2. 可结合`ANALYZE TABLE`更新表的统计信息。
3. MySQL 8.0+ 支持`EXPLAIN ANALYZE`查看实时执行信息。



# =====================================================


1. id：select 查询序列号。id相同，执行顺序由上至下；id不同，id值越大优先级越高，越先被执行。
2. select_type：查询数据的操作类型，其值如下：

- simple：简单查询，不包含子查询或 union
- primary:包含复杂的子查询，最外层查询标记为该值
- subquery：在 select 或 where 包含子查询，被标记为该值
- derived：在 from 列表中包含的子查询被标记为该值，MySQL 会递归执行这些子查询，把结果放在临时表
- union：若第二个 select 出现在 union 之后，则被标记为该值。若 union 包含在 from 的子查询中，外层 select 被标记为 derived
- union result：从 union 表获取结果的 select

1. table：显示该行数据是关于哪张表
2. partitions：匹配的分区
3. type：表的连接类型，其值，性能由高到底排列如下：

- system：表只有一行记录，相当于系统表
- const：通过索引一次就找到，只匹配一行数据
- eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常用于主键或唯一索引扫描
- ref：非唯一性索引扫描，返回匹配某个单独值的所有行。用于=、< 或 > 操作符带索引的列
- range：只检索给定范围的行，使用一个索引来选择行。一般使用between、>、<情况
- index：只遍历索引树
- ALL：全表扫描，性能最差 注：前5种情况都是理想情况的索引使用情况。通常优化至少到range级别，最好能优化到 ref

1. possible_keys：显示 MySQL 理论上使用的索引，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用。如果该值为 NULL，说明没有使用索引，可以建立索引提高性能
2. key：显示 MySQL 实际使用的索引。如果为 NULL，则没有使用索引查询
3. key_len：表示索引中使用的字节数，通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好 显示的是索引字段的最大长度，并非实际使用长度
4. ref：显示该表的索引字段关联了哪张表的哪个字段
5. rows：根据表统计信息及选用情况，大致估算出找到所需的记录或所需读取的行数，数值越小越好
6. filtered：返回结果的行数占读取行数的百分比，值越大越好
7. extra：包含不合适在其他列中显示但十分重要的额外信息，常见的值如下：

- using filesort：说明 MySQL 会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。出现该值，应该优化 SQL
- using temporary：使用了临时表保存中间结果，MySQL 在对查询结果排序时使用临时表。常见于排序 order by 和分组查询 group by。出现该值，应该优化 SQL
- using index：表示相应的 select 操作使用了覆盖索引，避免了访问表的数据行，效率不错
- using where：where 子句用于限制哪一行
- using join buffer：使用连接缓存
- distinct：发现第一个匹配后，停止为当前的行组合搜索更多的行
