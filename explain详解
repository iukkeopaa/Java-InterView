在 MySQL 中，`EXPLAIN` 是一个强大的分析工具，用于查看 SQL 查询的执行计划（Execution Plan）。通过它可以了解数据库如何执行查询，包括表的读取顺序、索引使用情况、数据过滤方式等，从而优化查询性能。

### **一、基本语法**

sql











```sql
EXPLAIN SELECT ...;  -- 用于SELECT语句
EXPLAIN DELETE ...;  -- 用于DELETE语句
EXPLAIN INSERT ...;  -- 用于INSERT语句
EXPLAIN UPDATE ...;  -- 用于UPDATE语句
```



**示例：**



sql











```sql
EXPLAIN SELECT * FROM users WHERE age > 18;
```

### **二、输出字段详解**

`EXPLAIN` 的输出通常包含以下关键列：

#### 1. **id**

- **含义**：查询的标识符，标识执行顺序（数字越大越先执行；相同数字按从上到下顺序执行）。

- 示例

  ：

  plaintext

  

  

  

  

  

  ```plaintext
  +----+-------------+-------+
  | id | select_type | table |
  +----+-------------+-------+
  | 1  | PRIMARY     | users |
  | 2  | SUBQUERY    | ...   |
  +----+-------------+-------+
  ```

#### 2. **select_type**

- 含义

  ：查询类型，常见值：

  - `SIMPLE`：简单查询（无子查询或 UNION）。
  - `PRIMARY`：主查询（包含子查询的外层查询）。
  - `SUBQUERY`：子查询。
  - `DERIVED`：派生表（FROM 子句中的子查询）。

#### 3. **table**

- **含义**：当前执行的表名（或别名）。

#### 4. **type**

- 含义

  ：连接类型，反映查询效率（从最优到最差）：

  - `system`/`const`：表只有一行数据，或通过主键 / 唯一索引直接匹配。
  - `eq_ref`：使用唯一索引（如主键）进行连接，每行仅匹配一条记录。
  - `ref`：使用非唯一索引或索引前缀匹配。
  - `range`：使用索引进行范围扫描（如`WHERE age > 18`）。
  - `index`：全索引扫描（遍历索引树）。
  - `ALL`：全表扫描（性能最差）。

#### 5. **possible_keys**

- **含义**：可能使用的索引。

#### 6. **key**

- **含义**：实际使用的索引。若为`NULL`，表示未使用索引。

#### 7. **key_len**

- **含义**：索引使用的字节数，反映索引的精确程度（值越小越精确）。

#### 8. **ref**

- **含义**：哪些列或常量用于与索引比较。

#### 9. **rows**

- **含义**：MySQL 估算需要扫描的行数（值越小性能越好）。

#### 10. **Extra**

- 含义

  ：额外信息，常见值：

  - `Using index`：使用覆盖索引（无需回表）。
  - `Using where`：使用 WHERE 子句过滤数据。
  - `Using temporary`：使用临时表（如 GROUP BY 或 ORDER BY）。
  - `Using filesort`：使用文件排序（性能较差）。

### **三、执行计划示例**

**查询：**



sql











```sql
EXPLAIN SELECT * FROM users 
JOIN orders ON users.id = orders.user_id 
WHERE users.age > 18 AND orders.status = 'paid';
```



**输出：**



plaintext











```plaintext
+----+-------------+-------+-------+---------------+---------+---------+----------------+--------+-------------+
| id | select_type | table | type  | possible_keys | key     | key_len | ref            | rows   | Extra       |
+----+-------------+-------+-------+---------------+---------+---------+----------------+--------+-------------+
| 1  | SIMPLE      | users | range | age_idx       | age_idx | 4       | NULL           | 1000   | Using where |
| 1  | SIMPLE      | orders| ref   | user_id_idx   | user_id_idx| 4     | users.id       | 5      | Using where |
+----+-------------+-------+-------+---------------+---------+---------+----------------+--------+-------------+
```



**分析：**



1. `users`表通过`age_idx`索引进行范围扫描（`type=range`），估算扫描 1000 行。
2. `orders`表通过`user_id_idx`索引与`users`表连接（`type=ref`），每行匹配 5 条记录。

### **四、性能优化建议**

1. **避免全表扫描（`type=ALL`）**

   - 为`WHERE`条件字段添加索引。

   - 示例：

     sql

     

     

     

     

     

     ```sql
     ALTER TABLE users ADD INDEX age_idx (age);
     ```

2. **减少临时表和文件排序**

   - 优化`GROUP BY`/`ORDER BY`字段，确保使用索引。

   - 示例：

     sql

     

     

     

     

     

     ```sql
     SELECT user_id, COUNT(*) FROM orders GROUP BY user_id;  -- 确保user_id有索引
     ```

3. **使用覆盖索引（`Using index`）**

   - 让索引包含所有需要查询的字段，避免回表。

   - 示例：

     sql

     

     

     

     

     

     ```sql
     SELECT user_id, order_id FROM orders WHERE status = 'paid';  -- 为(status, user_id, order_id)创建复合索引
     ```

     

     


4. **优化子查询**

   - 将子查询转换为`JOIN`，避免`DERIVED`类型的临时表。

### **五、注意事项**

1. `EXPLAIN`显示的是**估算数据**，实际执行可能不同（如统计信息过时）。
2. 可结合`ANALYZE TABLE`更新表的统计信息。
3. MySQL 8.0+ 支持`EXPLAIN ANALYZE`查看实时执行信息。
