## 本地缓存

1. 缓存的失效算法：LRU（最近最少使用）,LFU（最不常用）,FIFO（先进先出）,随机淘汰算法


## LFU的通常能带来最佳的缓存命中率，但是LFU有三个缺点


1. 它需要给每个记录项维护频率信息，每次访问都需要更新，需要一个巨大的空间记录所有出现过的 key 和其对应的频次；
2. 如果数据访问模式随时间有变，LFU 的频率信息无法随之变化，因此早先频繁访问的记录可能会占据缓存，而后期访问较多的记录则无法被命中；
3. 如果一个刚加入缓存的元素，它的频率并不高，那么它可能会会直接被淘汰。

其中第一个问题是实际中很少使用LFU的**主要原因**，所以为了实现**高命中率**和**低内存占用**，Caffine中的设计中使用了**W-TinyLFU**。


## 关于本地缓存和分布式缓存的一些思考

1. 首先**三级缓存**是一个常用的提高系统的性能的方法，**本地缓存**是指将数据存储在单个应用程序的内存中，它通常被用于提高应用程序的性能，减少对数据库等后端存储系统的请求次数。本地缓存的优点是速度快、易于使用和管理、并且不需要网络通信的开销，但是它只能在应用程序的本地节点使用，不能跨多个节点进行共享。也就是说，本地缓存在集群环境中，会存在不一致的问题，多个本地缓存之间的数据可能不一致。、相反
   分布式缓存是指将数据存储在多个节点的内存中，这些节点可以在不同的服务器上，甚至在不同的地理位置上。分布式缓存的优点是可以支持多个应用程序共享数据，提高系统的可伸缩性和可用性，但是它的管理和维护成本较高，需要考虑数据一致性和故障恢复等问题。但是实际的使用缓存的设计中可能不止这些缓存，其中**近端缓存**是个新的缓存方式，也就是在离用户越近的地方设置缓存，其中一个常见的是CDN，也就是内容分发网络。还有一种近端缓存，就是可以把Redis等这种分布式缓存在应用服务器上也部署一份，这样就使得查询缓存的时候不需要网络通信的远程调用，也能提升查询的速度。

2. 第二个问题就是如何保证本地缓存的一致性

首先我们需要明白一个概念就是本地缓存散布在各个不同的节点或者服务器上，那么本地缓存一致性是个很重要的问题，想要让本地缓存保持一致性，那么也就意味着，当一台机器上的本地缓存更新或者失效时，别的机器也要感知到，并且能及时处理。

- 第一个方法是我们给本地缓存记录一个版本，当某台机器的本地缓存更新之后，把他的最新的版本号以及缓存中的数据记录到数据库中，这样，当下次有请求请求到一个未更新过本地缓存的机器时，对比一下版本号，发现版本号旧了，那么就从数据库中更新一下本地缓存。
- 第二个方法是借助配置中心。当某一个机器上的本地缓存发生变更之后，向配置中心做一次配置变更，然后通过配置中心把变更再推送到每一台机器上，大家监听配置变化做本地缓存的更新。
- 第三个方法是借助MQ(Kafka、RocketMQ、RabbitMQ)的广播消息，可以实现这个功能，当有实例需要更新本地缓存的时候，发一个MQ的广播消息，然后所有实例监听到这个广播消息后，各自更新自己的本地缓存。
- 第四个方法是借助redis，pub/sub机制，订阅和发布机制，这种发布订阅模式有个致命的问题就是没有办法进行持久化的，如果出现网络断开、Redis宕机的话，消息就会丢失，这种也不是很推荐。我们使用使用的是redis的stream机制，Redis的Stream 可以理解成是Redis对消息队列MQ的完善实现，支持分组消费和广播消费，并且可以将消息进行持久化

> 这种通知清除缓存的功能是比较轻量级的，不是很频繁的操作，不像MQ那样是专门为了解决高并发下的问题，所以使用RedisStream就完全足够
> 
> 使用RedisStream只需要连接Redis即可，而基本每个项目都需要Redis，这样就不需要再额外引入中间件，没有额外的部署成本
> 
> RedisStream能够将数据保存到磁盘，以确保数据不会丢失
>
> RedisStream中的streamName和consumerType

- 第五个不是具体的方法，但是是一个指导性的思想。具体的来说就是首先，肯定是要评估数据的变化频率，对于变化不频繁的数据，才会考虑放到本地缓存中。那种频繁更新的数据，其实并不适合放到本地缓存。还有就是，要提前评估下业务上能否接收不一致，以及能接受的不一致的时长。如果接受不了不一致，那就绝对不能用本地缓存。 如果能接受，那么就基于业务上能接受的时长设置失效时长，比如业务上可以接受10分钟的延迟，那么我们可以设置个8分钟的超时时间。这样到期之后这个缓存的内容就会自动失效。
- 第六个方法是定时任务查询，定时从库中扫描失效的数据，对于已经失效的数据就在缓存中删除。这种只能应对简单而且数据量小的业务，而且不好估算定时任务的执行时间，频率高了对数据库的压力很大，频率低了缓存又不及时被清除，而且假如某段时间没有修改数据或者主动要失效的操作，那么就白执行了。而且这种多实例的情况，就只能每个实例都要查询一遍数据库，属实没有必要。




- 这里使用的两种方法

1. 自动失效

```java
Cache<String, String> cache = Caffeine.newBuilder()
                .expireAfterWrite(5, TimeUnit.SECONDS) // 设置缓存项写入后的过期时间为5秒
                .build();
```
在自动失效后，查询本地缓存就会有一次cache miss，然后下次再查询就会去分布式缓存查询，然后再缓存到本地缓存中即可。这样就能保持最新数据了。

2. 自动更新

```java
Cache<String, String> cache = Caffeine.newBuilder()
                .refreshAfterWrite(5, TimeUnit.SECONDS) // 设置缓存项写入后的自动刷新时间为5秒
                .build(new CacheLoader<String, String>() { //定义一个CacheLoader，实现load方法。
                 	@Override
                 	public ListenableFuture<String> reload(String key, String oldValue) throws Exception {
                     return remoteCache.get(key);
                	}
               });
```

在达到缓存刷新的时间后，Caffeine会自动调用load方法进行数据读取并更新。


## 如何设置本地缓存

1. 数据结构：一般来讲，为了提升缓存的效率，通常采用Key-Value结构进行数据存储，也就是说，缓存中的数据保存和读取都需要有一个Key，通过Key来读取固定的缓存的Value；
2. 线程安全：本地缓存一定要考虑线程安全的问题，因为大多数情况下本地缓存都是一个全局可访问的变量，那么就会有多个线程同时访问，所以线程安全问题不容忽视；
3. 对象上限：因为是本地缓存，而本地内存中的数据是要占用JVM的堆内存的，所以内存是有上限要求的，如果无限存储，最终一定会导致OOM的问题；
4. 清除策略：为了避免OOM的问题，一般会考虑在缓存中增加清除策略，通过一定的手段定期的清理掉一些数据，来保证内存占用不会过大，常见清除策略主要有有LRU(最近最少使用)、FIFO(先进先出)、LFU(最近最不常用)、SOFT(软引用)、WEAK(弱引用)等；
5. 过期时间：有了清除策略并不能保证百分百的可以删除数据，极端情况会会使得某些数据一直无法删除。这时候就需要有一种机制，能够保证某些K-V一定可以删除。通常采用的方案是给每一个缓存的key设置过期时间，当达到过期时间之后直接删除,采用清除策略+过期时间双重保证;
6. 最简单的方式是通过HashMap来实现一个本地缓存，因为他本身就是一种Key-Value结构的，并且如果使用ConcurrentHashMap的话，也能保证线程安全，不过需要自己实现对象上限、过期策略以及清除策略。
7. 一般使用的是Caffeine和Guava Cache，推荐优先使用Caffeine作为本地缓存，在功能上，GuavaCache支持的功能，Caffeine都支持，另外Caffeine支持异步Cache和写入外部资源，这两个Guava Cache是不支持的。Caffeine也是Spring 5中默认支持的Cache。而Caffeine在性能上要比GuavaCache好很多，主要有以下几个原因：

- 剔除算法，GuavaCache采用的是「LRU」算法，而Caffeine采用的是「Window TinyLFU」算法，这是两者之间最大，也是根本的区别。
- 立即失效，Guava会把立即失效 (例如：expireAfterAccess(0) and expireAfterWrite(0)) 转成设置最大Size为0。这就会导致剔除提醒的原因是SIZE而不是EXPIRED。Caffeine能正确识别这种剔除原因。
- 取代提醒，Guava只要数据被替换，不管什么原因，都会触发剔除监听器。而Caffeine在取代值和先前值的引用完全一样时不会触发监听器。
- 异步化，Caffeine的很多工作都是交给线程池去做的（默认：ForkJoinPool.commonPool()），例如：剔除监听器，刷新机制，维护工作等。