### 一、SQL 中 `COUNT(*)`、`COUNT(字段)`、`COUNT(1)` 的效率对比

在数据库查询中，聚合函数的效率主要受 **是否需要判断字段为 NULL**、**是否使用索引**、**数据库引擎优化** 影响，核心结论：
**效率排序（通常）：`COUNT(\*)` ≈ `COUNT(1)` ≥ `COUNT(非NULL索引字段)` > `COUNT(普通字段，可能含NULL)`**

#### 1. `COUNT(*)` 的效率

- **优势**：
  `COUNT(*)` 是 SQL 标准中统计 “总行数” 的最优方式，**几乎所有数据库引擎都会对其做特殊优化**。
  - 它不需要检查任何字段的值（无论字段是否为 NULL），仅需统计 “存在的行”，逻辑最简单。
  - 部分数据库（如 MySQL 的 MyISAM 引擎）会在表元数据中直接存储总行数，`COUNT(*)` 可直接返回结果（O (1) 时间）；即使是 InnoDB 等事务引擎，也会优先选择最小的索引（如二级索引）进行扫描，减少 IO 成本。
- **场景**：统计全表行数时，`COUNT(*)` 是效率最高的选择。

#### 2. `COUNT(字段)` 的效率

- 取决于字段是否为 NULL 及是否有索引

  ：

  - **若字段是 “非 NULL 且有索引”（如主键、非 NULL 唯一索引）**：
    例如 `COUNT(id)`（id 是主键，非 NULL），此时数据库会优化为 “统计所有行”（因为主键不可能为 NULL），效率接近 `COUNT(*)`。
    原因：索引本身不存储 NULL 值（或主键索引强制非 NULL），数据库可直接通过索引快速统计行数，无需逐行判断。
  - **若字段 “可能为 NULL 且无索引”**：
    例如 `COUNT(age)`（age 允许 NULL，且无索引），数据库需要逐行扫描表数据，检查每个 `age` 是否为 NULL，再计数。此时效率极低（全表扫描 + 逐行判断），数据量越大，耗时越明显。
  - **若字段 “可能为 NULL 但有索引”**：
    效率优于无索引的情况（可通过索引扫描而非全表扫描），但仍需在索引中过滤 NULL 值（索引不存储 NULL 时除外），因此略慢于 `COUNT(*)`。

#### 3. `COUNT(1)` 的效率

`COUNT(1)` 中 “1” 是常量（非 NULL），因此逻辑上等同于 “统计所有行”（和 `COUNT(*)` 一致）。
在多数数据库（如 MySQL、PostgreSQL）中，优化器会将 `COUNT(1)` 和 `COUNT(*)` 视为等价操作，效率完全相同。
少数数据库可能对 `COUNT(*)` 有更深度的优化（如直接读取总行数元数据），但差异微乎其微。

#### 数据库差异补充

- **MySQL InnoDB**：
  无总行数缓存，`COUNT(*)` 需扫描索引（优先选最小的二级索引），效率略高于 `COUNT(字段)`（除非字段是主键）。
- **MySQL MyISAM**：
  存储表总行数，`COUNT(*)` 可直接返回（O (1)），效率远高于 `COUNT(字段)`。
- **PostgreSQL**：
  `COUNT(*)` 和 `COUNT(1)` 优化相同，`COUNT(字段)` 需检查 NULL，效率更低。
