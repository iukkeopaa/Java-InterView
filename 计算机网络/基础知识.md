### HTTP 基于 TCP 还是 UDP？

HTTP（超文本传输协议）**基于 TCP 协议**工作。



原因在于，HTTP 的核心需求是**可靠的数据传输**：客户端发送的请求（如获取网页、提交表单）和服务器返回的响应（如 HTML 内容、图片）必须完整、有序地送达，不允许丢失或乱序 ―― 否则会导致网页显示异常、文件传输错误等问题。而 TCP 协议通过三次握手建立连接、确认机制、重传机制等特性，恰好能保证数据的可靠传输，满足 HTTP 的需求。



不过需要注意一个例外：**HTTP/3（最新的 HTTP 版本）基于 UDP 协议**。它通过 QUIC（一种基于 UDP 的传输层协议）实现，在保留 UDP 低延迟优势的同时，通过自身设计弥补了 UDP 的不可靠性（如增加重传、加密等机制），进一步优化了实时性和性能。但传统的 HTTP/1.1、HTTP/2 均基于 TCP。



综上，通常所说的 HTTP（尤其是主流的历史版本）基于 TCP；仅最新的 HTTP/3 基于 UDP。


### 为什么 HTTP/3 要做这个改变呢

HTTP/3 从 TCP 转向 UDP 的核心改变，主要是为了彻底解决 TCP 协议的两大固有缺陷，并充分利用 UDP 的灵活性实现性能跃升。以下是两大核心原因：

### 一、彻底解决 TCP 的 ** 队头阻塞（Head-of-Line Blocking）** 问题

TCP 是基于字节流的顺序传输协议，所有数据必须按顺序接收和确认。如果某个数据包丢失，即使后续数据包已到达，接收方也会被强制阻塞，直到丢失的包被重传并确认。这种现象在 HTTP/2 中尤为突出：虽然 HTTP/2 通过多路复用实现了应用层的并行传输，但 TCP 层的阻塞会导致所有数据流暂停，例如视频卡顿、网页加载中断等问题。



而 HTTP/3 通过**QUIC 协议**（基于 UDP）彻底解决了这一问题：



- **独立数据流**：每个 HTTP 请求对应 QUIC 中的一个独立 “流”，每个流的数据包单独传输和确认。即使某个流的数据包丢失，其他流仍可正常传输，不会相互影响。
- **灵活重传机制**：QUIC 在应用层实现重传逻辑，仅重传丢失的数据包，避免了 TCP 全局阻塞的问题。例如，在丢包率 5% 的网络环境下，HTTP/3 的加载速度比 HTTP/2 快 40%。

### 二、大幅减少**连接建立延迟**，提升弱网性能

TCP 的连接建立和加密握手需要多次往返时间（RTT）：



- **TCP 三次握手**：至少 1 个 RTT；
- **TLS 加密握手**：额外 1-2 个 RTT；
- **总计**：HTTP/2 首次连接需要 2-3 个 RTT，在高延迟网络（如跨国传输）中可能超过 300 毫秒。



HTTP/3 通过 QUIC 的**0-RTT 和 1-RTT 机制**彻底优化了这一过程：



- **0-RTT 连接**：对于重复访问的站点，客户端可直接复用之前的加密密钥，无需任何 RTT 即可发送数据。实测显示，移动网络下连接建立时间可减少 30-50%。
- **1-RTT 握手**：首次连接时，QUIC 将 TLS 握手与数据传输合并，仅需 1 个 RTT 即可完成加密协商和数据发送，相比 HTTP/2 减少 50% 以上的延迟。

### 三、额外优势：UDP 的灵活性与协议创新

除了上述两大核心原因，UDP 的特性还为 HTTP/3 带来了以下创新：



1. **连接迁移**：QUIC 使用 64 位随机数作为连接 ID，而非 TCP 的 “IP + 端口” 四元组。当设备切换网络（如从 Wi-Fi 到蜂窝网络）时，连接 ID 不变，避免了 TCP 因 IP 变化导致的重连。
2. **用户态协议栈**：QUIC 的拥塞控制、流量控制等功能在应用层实现，无需依赖操作系统内核。这使得协议升级更灵活，例如 B 站通过 QUIC 优化了视频卡顿率（降低 5%）和首帧加载速度（提升 10%）。
3. **强制加密**：QUIC 内置 TLS 1.3，所有数据默认加密，避免了 HTTP/2 中可能存在的明文传输风险。

### 总结

HTTP/3 的改变本质上是**传输层协议的范式革命**：通过 UDP 的灵活性和 QUIC 的创新设计，彻底解决了 TCP 的性能瓶颈，同时保留了可靠传输的核心需求。这一改变尤其对移动网络、高延迟环境和实时应用（如视频、游戏）意义重大。尽管目前 HTTP/3 的普及度仍低于 HTTP/2，但随着浏览器和服务器的逐步支持（如 Chrome、Firefox 默认启用），它已成为优化现代网络体验的关键技术。

## 转发和重定向的区别是什么？

在 Web 开发中，**转发（Forward）**和**重定向（Redirect）**都是将请求从一个地方转发到另一个地方的技术手段，但它们在工作机制、用途和效果上存在一些关键的区别。

| 特性     | 转发（Forward）        | 重定向（Redirect）                           |
| -------- | ---------------------- | -------------------------------------------- |
| 请求处理 | 服务器内部处理请求     | 客户端发起新请求                             |
| URL变化  | 不变化                 | URL 变化                                     |
| 请求共享 | 可以共享请求属性       | 不能共享请求属性                             |
| 性能     | 性能较好（无额外请求） | 性能较差（有额外请求）                       |
| 适用场景 | 同一应用内的逻辑转移   | 需要用户重新请求的场景，例如登录、表单提交后 |

### 转发（Forward）

1. **概念**：
    - 转发是由服务器内部处理请求，原请求的控制权转移到另一个资源（如 JSP、Servlet）上，但客户端并不知道这一变化。
2. **工作机制**：
    - 使用 `RequestDispatcher` 的 `forward()` 方法来实现。服务器将请求和响应对象直接传递给目标资源。
    - URL 不会改变，浏览器的地址栏依然显示原始请求的 URL。
3. **用途**：
    - 常用于在同一服务器上将请求转发到另一个处理逻辑上，例如在某个 Servlet 中处理完业务逻辑后，将请求转发到 JSP 页面进行结果展示。
4. **性能**：
    - 转发过程相对较快，因为没有额外的 HTTP 请求和响应的创建，所有操作都在服务器内部完成。
5. **请求对象的共享**：
    - 转发后，原请求的属性（如通过 `request.setAttribute()` 设置的属性）可以在目标资源中访问。

### 重定向（Redirect）

1. **概念**：
    - 重定向是服务器向客户端发出新的请求指令，告诉浏览器去请求另一个 URL。浏览器会创建一个新的请求。
2. **工作机制**：
    - 使用 `HttpServletResponse` 的 `sendRedirect()` 方法来实现。服务器返回一个 3xx 状态码（通常是 302），并在响应头中指定新的 URL。
    - 浏览器会根据这个 URL 发送新的请求，地址栏中的 URL 会更新为新的 URL。
3. **用途**：
    - 常用于需要更新 URL 的场景，比如表单提交后重定向到一个结果页面，或实现用户权限控制时，将未登录用户重定向到登录页面。
4. **性能**：
    - 重定向涉及到一次完整的 HTTP 请求过程（原请求 + 重定向请求），因此性能相对较慢。
5. **请求对象的共享**：
    - 重定向后，原请求的属性不能直接共享，因为它们在两个不同的请求中。若需要传递数据，通常使用 URL 参数、会话（Session）或 Cookie。


## 绕过 Cookie 继续运行 Session

1. **URL 中携带 SessionID**：可以通过 URL 重写的方式将 Session ID 添加到所有的 URL 中。服务器生成 Session ID 后，将其作为 URL 的一部分传递给客户端，客户端在后续的请求中将 Session ID 带在 URL 中。服务器端需要相应地解析 URL 来获取 Session ID，并维护用户的会话状态。
2. **隐藏表单字段传递 SessionID**：将 Session ID 添加到 HTML 表单的隐藏字段中。在每个表单中添加一个隐藏的字段，保存 Session ID，客户端提交表单时会将 Session ID 随表单数据一起发送到服务器，服务器通过解析表单数据中的 Session ID 来获取用户的会话状态。

这些方法虽然可以在禁用 Cookie 的情况下继续使用 Session，但需要在服务器端进行相应的代码修改和配置。但同时这些手段也带来了以下几个新问题：

1. **增加了编码复杂度**：需要改前端和后端代码才能继续使用 Session 机制，增加了编码复杂度。
2. **增加了安全风险**：这些替代方法可能会增加一些安全风险，因为 Session ID 将以明文形式出现在 URL 或表单中，很容易被第三方劫持和获取




## 为什么要先用非对称算法加密，后面又用对称算法？


### 先理解两种算法的核心特点：

- **对称加密算法**（如 AES、DES）：
  加密和解密使用**同一个密钥**（对称密钥），特点是：
   - 优点：加密速度极快（适合处理大量数据，如文件、视频、长文本），计算开销小。
   - 缺点：**密钥传输问题**―― 如果通信双方要使用对称加密，必须先把对称密钥传给对方，但直接传输密钥时，一旦被黑客截获，后续所有加密数据都会被破解。
- **非对称加密算法**（如 RSA、ECC）：
  加密和解密使用**一对不同的密钥**（公钥和私钥）：公钥可以公开，任何人都能用公钥加密数据，但只有对应的私钥才能解密；反之，用私钥加密的数据，只有公钥能解密。特点是：
   - 优点：**无需传输私钥**，只需公开公钥即可安全传输加密信息（比如用对方公钥加密的数据，只有对方的私钥能解密），解决了 “密钥传输安全” 问题。
   - 缺点：加密速度很慢（比对称算法慢 100-1000 倍），不适合处理大量数据（比如加密一个 1GB 的文件，耗时会非常长）。

### 为什么要 “先非对称、后对称”？

单独使用任何一种算法都有明显缺陷：



- 若只使用对称加密：密钥传输不安全，一旦密钥泄露，整个通信被破解。
- 若只使用非对称加密：加密大量数据时效率极低，无法满足实际通信需求（比如视频通话、文件传输）。



**混合策略的逻辑**：



1. **先用非对称算法解决 “对称密钥的安全传输”**：
   通信双方先通过非对称算法交换一个 “临时的对称密钥”。例如：
   - A 生成一个随机的对称密钥（比如 AES 密钥）；
   - A 用 B 的公钥加密这个对称密钥，然后发给 B；
   - B 收到后，用自己的私钥解密，得到对称密钥。
     由于公钥加密的数据只有私钥能解密，这个过程中对称密钥不会被黑客截获。
2. **再用对称算法加密后续的大量数据**：
   双方拿到相同的对称密钥后，后续所有通信数据（比如聊天内容、文件、视频流）都用这个对称密钥加密。
   由于对称算法速度极快，即使处理海量数据也能保证效率，同时因为密钥是通过非对称算法安全传输的，整体通信是安全的。

### 典型应用场景：HTTPS 协议

HTTPS 是这种混合策略的典型案例：



- 客户端（浏览器）和服务器先通过 “非对称加密”（如 RSA）完成 “对称密钥”（如 AES 密钥）的交换（这个过程叫 “握手”）；
- 握手结束后，后续所有 HTTP 数据的传输都用这个对称密钥加密，既保证安全，又不影响浏览速度。

### 总结

“先非对称、后对称” 的本质是：



- 用非对称算法的 “密钥管理优势” 解决对称密钥的安全传输问题；
- 用对称算法的 “高效加密优势” 处理大量数据的加密需求。
  两者结合，既满足了安全性，又保证了效率，是目前主流加密通信的标准方案。

## redis String的底层数据结构是什么

### **一、基础存储结构：SDS（Simple Dynamic String）**

Redis 没有直接使用 C 语言的字符串（以`\0`结尾的字符数组），而是自定义了 ** 简单动态字符串（SDS）** 作为底层实现，核心结构如下：



c



运行









```c
struct sdshdr {
    int len;       // 当前字符串实际长度（不包含\0）
    int free;      // 剩余可用空间（字节）
    char buf[];    // 存储字符串的字节数组
};
```






#### **SDS 的优势**：

1. **获取长度的时间复杂度为 O (1)**
   C 字符串获取长度需遍历整个数组（O (n)），而 SDS 直接读取`len`字段（O (1)）。
2. **二进制安全**
   SDS 可存储任意二进制数据（如图片、序列化对象），而 C 字符串只能存储文本（因以`\0`作为结束符）。
3. **减少内存重分配次数**
   通过`free`字段预分配空间，避免频繁内存重分配（如`append`操作时，若空间不足会按 2 倍扩容）。
4. **兼容 C 字符串函数**
   SDS 的`buf`数组以`\0`结尾，可直接使用部分 C 字符串函数。

### **二、编码类型的动态转换**

Redis 为 String 类型提供了三种编码方式，根据存储内容自动转换：

#### **1. INT 编码**

- **适用场景**：当存储的字符串可以被解析为**整数**，且值在 64 位有符号整数范围内时，使用 INT 编码。
- **存储方式**：直接将整数值保存在 RedisObject 的`ptr`字段中（无需额外内存）。



**示例**：



bash











```bash
SET num 123456  # 使用INT编码
```

#### **2. EMBSTR 编码（embstr = Embedded String）**

- **适用场景**：当存储的字符串长度**≤ 44 字节**（Redis 5.0 及以后版本，之前为 39 字节）时，使用 EMBSTR 编码。
- **存储方式**：
  将 RedisObject 和 SDS 结构连续存储在一块内存中，避免内存碎片，提高访问效率。



**结构示意图**：



plaintext











```plaintext
[RedisObject][sdshdr][buf]
```

#### **3. RAW 编码**

- **适用场景**：当存储的字符串长度 **> 44 字节 ** 时，使用 RAW 编码。
- **存储方式**：
  RedisObject 和 SDS 结构分开存储（分别分配内存），适合存储大字符串。



**结构示意图**：



plaintext











```plaintext
RedisObject → sdshdr → buf
```

### **三、编码转换规则**

Redis 会根据字符串的内容和长度自动转换编码：



1. **INT → EMBSTR/RAW**
   若对 INT 编码的键执行`APPEND`等操作，使其变为非整数，或值超出 64 位范围，则转换为 EMBSTR 或 RAW。
2. **EMBSTR → RAW**
   若对 EMBSTR 编码的键执行`APPEND`等操作，导致字符串长度超过 44 字节，则转换为 RAW（EMBSTR 不可修改，需重新分配内存）。

### **四、为什么要区分 EMBSTR 和 RAW？**

1. **内存效率**
   EMBSTR 将 RedisObject 和 SDS 连续存储，减少内存碎片，适合小字符串；RAW 则适合大字符串，避免一次性分配大块内存。
2. **性能优化**
   EMBSTR 的创建和释放只需一次内存分配 / 释放（因连续存储），而 RAW 需要两次。对于频繁操作的小字符串，EMBSTR 性能更优。

### **五、如何查看编码类型？**

使用 Redis 的`OBJECT ENCODING`命令：



bash











```bash
SET small "hello"
OBJECT ENCODING small  # 输出 "embstr"

SET large "x".repeat(100)  # 创建一个100字节的字符串
OBJECT ENCODING large  # 输出 "raw"

SET num 123
OBJECT ENCODING num  # 输出 "int"
```

### **六、总结**

| 编码类型 | 适用场景              | 优势                              |
| -------- | --------------------- | --------------------------------- |
| INT      | 整数值（≤ 64 位）     | 直接存储数值，无需额外内存        |
| EMBSTR   | 短字符串（≤ 44 字节） | 内存连续，减少碎片，创建 / 释放快 |
| RAW      | 长字符串（> 44 字节） | 灵活存储大字符串，避免内存浪费    |



这种动态编码策略使 Redis 在保证功能灵活性的同时，最大化内存利用率和操作效率

## 服务器上如果有很多time wait如何解决，以及出现这个问题的场景有哪些

### **一、TIME_WAIT 状态的本质与作用**

1. **TCP 四次挥手的最后阶段**
   当客户端或服务器主动关闭连接时，会经历四次挥手：

   plaintext











   ```plaintext
   客户端 → FIN → 服务器 （客户端进入FIN_WAIT_2）
   服务器 → ACK → 客户端 （服务器进入CLOSE_WAIT）
   服务器 → FIN → 客户端 （服务器进入LAST_ACK）
   客户端 → ACK → 服务器 （客户端进入TIME_WAIT，持续2*MSL时间）
   ```






**TIME_WAIT 的作用**：

- 确保最后一个 ACK 能被对方收到（若服务器未收到 ACK，会重发 FIN）；
- 防止旧连接的数据包混入新连接（等待 2*MSL 时间，确保网络中所有延迟的数据包都已消失）。

2. **MSL（Maximum Segment Lifetime）**
   指 TCP 数据包在网络中的最大生存时间，RFC 规定为 2 分钟，但实际通常设为 30 秒或 60 秒。

### **二、大量 TIME_WAIT 出现的常见场景**

1. **高并发短连接服务**
    - 典型如 HTTP 服务器（尤其是使用`Connection: close`强制短连接的场景），每次请求都会创建新连接并在响应后关闭，导致 TIME_WAIT 堆积。
2. **服务器主动关闭连接**
    - 若服务器作为 TCP 连接的主动关闭方（如负载均衡器、代理服务器），会进入 TIME_WAIT 状态。
3. **客户端与服务器 IP:PORT 组合耗尽**
    - 客户端使用固定源端口频繁与服务器建立连接时，可能导致本地端口耗尽（客户端端口范围通常为 32768-61000）。
4. **网络异常或程序逻辑错误**
    - 频繁重连、连接未正常关闭（如程序崩溃）可能导致 TIME_WAIT 积累。

### **三、解决方案**

#### **1. 调整系统内核参数（推荐）**

修改`/etc/sysctl.conf`并执行`sysctl -p`生效：



bash











```bash
# 允许将TIME_WAIT状态的socket重新用于新连接（默认0）
net.ipv4.tcp_tw_reuse = 1

# 缩短TIME_WAIT状态的超时时间（默认60秒）
net.ipv4.tcp_fin_timeout = 30

# 增大TIME_WAIT连接的数量上限（默认180000）
net.ipv4.tcp_max_tw_buckets = 5000

# 开启TCP时间戳（配合tcp_tw_reuse使用）
net.ipv4.tcp_timestamps = 1
```

#### **2. 调整应用程序设计**

- **使用长连接替代短连接**：
  如 HTTP/1.1 默认的`Connection: keep-alive`或 HTTP/2 的多路复用，减少连接创建和关闭频率。
- **优化程序逻辑**：
  避免频繁主动关闭连接，确保连接池正确释放资源，减少异常关闭。
- **负载均衡与分布式架构**：
  将请求分散到多个服务器，避免单节点 TIME_WAIT 过多。

#### **3. 调整服务器角色**

- **避免服务器主动关闭连接**：
  通过配置让客户端主动关闭连接（如调整负载均衡器的连接超时策略）。

#### **4. 其他高级选项**

- **增大本地端口范围**：

  bash











  ```bash
  net.ipv4.ip_local_port_range = 10000 65535  # 扩大客户端可用端口范围
  ```

- **启用 TCP 快速回收（谨慎使用）**：

  bash











  ```bash
  net.ipv4.tcp_tw_recycle = 1  # 不推荐在NAT环境使用，可能导致数据包丢失
  ```

### **四、不同场景下的最佳实践**

| 场景                   | 优先级解决方案                        | 注意事项                        |
| ---------------------- | ------------------------------------- | ------------------------------- |
| 高并发 HTTP 服务器     | 1. 启用 tcp_tw_reuse + tcp_timestamps | 需内核支持（Linux 2.4+）        |
|                        | 2. 调整 tcp_fin_timeout 至 30 秒      | 可能影响异常连接的回收          |
| 短连接客户端（如爬虫） | 1. 增大本地端口范围                   | 需确保系统能支持大量连接        |
|                        | 2. 使用连接池（如 HTTP 连接池）       | 减少连接创建频率                |
| NAT 环境下的服务器     | 1. 禁用 tcp_tw_recycle                | 可能导致 NAT 后的客户端连接异常 |
|                        | 2. 优化负载均衡策略                   | 分散连接到多个服务器            |

### **五、如何监控 TIME_WAIT 状态**

1. **统计 TIME_WAIT 连接数量**：

   bash











   ```bash
   netstat -an | grep TIME_WAIT | wc -l
   ```

2. **查看内核参数当前值**：

   bash











   ```bash
   sysctl net.ipv4.tcp_tw_reuse
   sysctl net.ipv4.tcp_fin_timeout
   ```

3. **监控端口使用情况**：

   bash











   ```bash
   ss -tan | awk '{print $2}' | sort | uniq -c | sort -n  # 统计各状态连接数量
   ```

### **六、总结**

大量 TIME_WAIT 本质是 TCP 协议设计的结果，通常无需过度担忧。但若已影响服务（如端口耗尽、系统资源紧张），可通过**内核参数调整**、**应用优化**和**架构改进**缓解。优先考虑调整`tcp_tw_reuse`和`tcp_fin_timeout`，慎用`tcp_tw_recycle`，并结合连接池和长连接设计从根源减少问题。


## 三次握手四次挥手  挥手什么时候能退化

### 为什么四次挥手不能完全 “退化”？

TCP 连接的关闭需要双方分别终止各自的发送方向（即 “双向关闭”），四次挥手的每一步都有不可替代的作用：

1. 客户端发送`FIN`（终止自己的发送方向）→ 第一次挥手；
2. 服务器回复`ACK`（确认收到客户端的关闭请求，但自己可能还有数据要发）→ 第二次挥手；
3. 服务器数据发送完毕，发送`FIN`（终止自己的发送方向）→ 第三次挥手；
4. 客户端回复`ACK`（确认收到服务器的关闭请求）→ 第四次挥手。

核心原因是：**双方关闭发送方向的时机可能不同步**（比如服务器收到客户端的`FIN`后，可能还需要继续发送数据，不能立即关闭自己的发送方向）。因此，必须通过两次独立的`FIN`（分别终止双方发送方向）和两次`ACK`（确认对方的关闭请求）来保证可靠性。

### 什么情况下会 “退化” 为三次挥手？

当服务器收到客户端的`FIN`后，**没有剩余数据需要发送**，此时可以将 “第二次挥手（`ACK`）” 和 “第三次挥手（`FIN`）” 合并为一个报文（`FIN+ACK`），从而减少一次挥手，变成 “三次挥手”。

这种情况本质是**报文合并优化**，而非协议流程的 “退化”―― 核心的两次`FIN`（双方关闭）和两次确认（`ACK`）机制仍在，只是通过合并减少了一次报文交互。

### 总结

四次挥手的 “退化”（减少次数）仅在**服务器无需延迟关闭自己的发送方向**时发生（即`ACK`和`FIN`合并），此时会优化为三次挥手。但由于 TCP 全双工特性和可靠性要求，**无法进一步减少到两次或一次挥手**（会导致一方无法确认对方是否已完成关闭，可能引发数据丢失或资源泄漏）。

因此，“四次挥手” 是 TCP 连接关闭的基础流程，“三次挥手” 是特定场景下的优化，而非真正意义上的 “退化”


## 计算机网络中ICMP的过程

ICMP（Internet Control Message Protocol，互联网控制消息协议）是 TCP/IP 协议族中网络层的核心协议之一，主要用于在 IP 主机、路由器之间传递**控制消息**（如错误报告、网络诊断信息等），帮助排查网络故障或调整数据传输行为。其工作过程可分为**错误报告**和**查询消息**两大类，具体如下：

### **一、ICMP 的基本定位**

- ICMP 依赖 IP 协议进行传输（封装在 IP 数据报中），本身不提供可靠性保证（无重传机制）。
- 作用：反馈网络层的异常状态（如 “目的不可达”）、支持网络诊断（如`ping`测试连通性）。

### **二、错误报告过程**

当路由器或主机在处理 IP 数据包时遇到异常（如无法转发、超时等），会生成**ICMP 错误报文**并发送给源主机，告知错误原因。

#### 1. 错误触发场景（常见）

- **目的不可达**：路由器找不到到达目标 IP 的路径，或主机无法接收（如端口未开放）。
- **超时**：数据包的 TTL（生存时间）减为 0 仍未到达目标（避免环路）。
- **参数错误**：IP 首部字段格式错误（如校验和无效、版本号错误）。
- **重定向**：路由器告知源主机 “有更优路径”（通常用于局域网内调整路由）。

#### 2. 错误报文发送过程

以 “目的不可达” 为例，步骤如下：

1. **异常检测**：路由器收到一个 IP 数据包，查找路由表发现无到达目标 IP 的路径，判定 “目的不可达”。

2. 构造 ICMP 错误报文

   ：

    - 类型字段：设为 3（表示 “目的不可达”）。
    - 代码字段：细分错误原因（如代码 0 表示 “网络不可达”，代码 3 表示 “端口不可达”）。
    - 携带原 IP 数据包的前 8 字节（含源 IP、目标 IP、协议类型等），供源主机识别对应的原始数据包。

3. **封装与发送**：ICMP 错误报文被封装到一个新的 IP 数据报中，源 IP 设为路由器自身 IP，目标 IP 设为原数据包的源 IP。

4. **源主机处理**：源主机收到 ICMP 错误报文后，解析类型和代码，得知错误原因（如 “目标端口未开放”），并终止对应的数据传输或调整行为。

### **三、查询消息过程**

查询消息是**双向交互**的，用于主动诊断网络状态（如测试连通性、获取目标信息）。源主机发送**ICMP 查询报文**，目标主机 / 路由器收到后返回**ICMP 应答报文**。

#### 1. 典型场景：`ping`命令（回声请求与应答）

`ping`是最常用的 ICMP 查询应用，用于测试源主机与目标主机的连通性，步骤如下：

1. **源主机发送 “回声请求”**：
    - 源主机（如主机 A）构造 ICMP “回声请求” 报文：
        - 类型字段：设为 8（表示 “回声请求”）。
        - 包含 “标识符”（区分不同 ping 进程）和 “序列号”（标识报文顺序）。
        - 可选数据区（通常填充随机数据，用于校验完整性）。
    - 报文被封装到 IP 数据报中，源 IP 为 A 的 IP，目标 IP 为被测试主机 B 的 IP，发送给 B。
2. **目标主机应答**：
    - 主机 B 收到 IP 数据报，提取 ICMP 请求报文，验证格式无误后，构造 “回声应答” 报文：
        - 类型字段：设为 0（表示 “回声应答”）。
        - 复制请求报文中的标识符、序列号和数据区（确保源主机能匹配请求与应答）。
    - 应答报文封装到 IP 数据报中，源 IP 为 B 的 IP，目标 IP 为 A 的 IP，返回给 A。
3. **源主机处理结果**：
    - 主机 A 收到应答后，计算 “往返时间（RTT）”（发送请求到接收应答的时间）。
    - 若超时未收到应答，判定 “目标不可达” 或 “网络丢包”。

### **四、其他重要特性**

- **不用于数据传输**：ICMP 仅传递控制信息，不承载用户数据。
- **报文大小限制**：ICMP 错误报文通常不超过 576 字节（避免 IP 分片过多）。
- **安全性**：ICMP 可能被滥用（如 “ping 洪水攻击”），部分网络会限制 ICMP 报文传输。

### **总结**

ICMP 的核心过程是 “异常反馈” 和 “主动查询”：通过错误报文告知源主机网络异常，通过查询报文（如 ping）诊断网络连通性，是 TCP/IP 协议族中保障网络可靠性的重要机制。

## ICMP为什么不需要端口号

### 1. **端口号的本质作用：标识传输层的 “应用端点”**

端口号是**传输层（TCP/UDP）** 的核心概念，其作用是：在一台主机上，区分不同的**应用程序或进程**。
例如，主机收到一个 TCP 数据包时，通过目标端口号（如 80 对应 HTTP、443 对应 HTTPS），才能知道该将数据交给浏览器还是其他应用。
**本质**：端口号是 “传输层到应用层” 的 “端点标识”，解决 “一台主机上多个应用共享网络资源” 的问题。

### 2. **ICMP 的定位：网络层的 “控制消息协议”，不涉及应用层**

ICMP 是**网络层协议**，它的作用是在 IP 主机、路由器之间传递**网络层自身的控制消息**（如错误报告、诊断信息），这些消息的处理者是**主机或路由器的网络层**，而非应用层的某个具体程序。

例如：

- 当路由器发现 “IP 包无法送达目标” 时，生成的 “目的不可达” ICMP 报文，是由路由器的网络层发送给源主机的网络层，告知 “网络层传输失败”，与应用层无关。
- `ping`命令中，“回声请求 / 应答” 报文是由主机的网络层处理（生成、解析），直接反馈给操作系统的网络诊断模块，而非某个应用程序。

### 3. **ICMP 的消息无需 “区分应用”，自然不需要端口号**

端口号的核心需求是 “区分应用”，但 ICMP 的消息：

- 要么是网络设备（路由器 / 主机）的网络层自身产生的（如错误报文），
- 要么是网络层直接处理的诊断消息（如 ping），
  均不涉及 “多个应用共享资源” 的场景，因此无需通过端口号标识 “目标应用”。

### 4. **协议栈层级的逻辑：网络层不依赖传输层的 “端口” 概念**

ICMP 封装在 IP 数据报中（属于网络层），而端口号是传输层的字段（TCP/UDP 首部）。从协议栈层级看：

- 网络层（IP/ICMP）的核心是 “主机到主机” 的通信（通过 IP 地址标识主机），
- 传输层（TCP/UDP）的核心是 “进程到进程” 的通信（通过 IP + 端口标识进程）。

ICMP 的消息仅需 “主机级” 的定位（通过 IP 地址），无需 “进程级” 的定位（端口号），因此自然不设计端口号字段。

### 总结

端口号是传输层为 “区分应用程序” 而设计的，而 ICMP 是网络层用于 “自身控制消息传递” 的协议，其消息的产生和处理均在网络层，不涉及应用程序，因此无需端口号。
这本质上是**不同协议层级的设计目标差异**导致的：网络层关注 “主机间通信”，传输层关注 “主机内应用间通信”，ICMP 属于前者，因此与端口号无关。

##

HEAD 和 GET 是 HTTP 中两种相似但用途不同的请求方法，核心区别在于**响应内容**，以及由此衍生的使用场景。具体区别如下：

### 1. **响应内容的差异（最核心）**

- **GET 方法**：服务器处理请求后，会返回**完整的响应**，包括**响应头（Headers）** 和**响应体（Body）**（即资源的实际内容，如网页 HTML、图片二进制数据、API 返回的 JSON 等）。
- **HEAD 方法**：服务器处理请求的逻辑与 GET 完全一致（例如验证权限、查找资源），但**仅返回响应头（Headers），不返回响应体（Body）**。

### 2. **使用场景的差异**

- **GET**：用于**获取资源的实际内容**，是最常用的方法。例如：
    - 浏览器访问网页（获取 HTML 内容）；
    - 调用 API 获取用户列表（返回 JSON 数据）；
    - 下载图片（获取二进制数据）。
- **HEAD**：用于**获取资源的元数据（不关心实际内容）**，主要目的是 “检查资源状态” 或 “获取资源属性”，以节省带宽（无需传输 body）。例如：
    - 检查某个链接是否有效（通过响应状态码：200 表示存在，404 表示不存在）；
    - 获取文件大小（通过响应头 `Content-Length`）、类型（`Content-Type`）或最后修改时间（`Last-Modified`）；
    - 验证资源是否更新（对比 `ETag` 或 `Last-Modified` 与本地缓存）。

### 3. **其他共性与细节**

- **安全性和幂等性**：两者均为 “安全方法”（不修改服务器资源）和 “幂等方法”（多次请求结果一致），这一点完全相同。
- **请求方式**：两者的请求参数均通过 URL query 字符串传递（不建议用 body，如前所述），请求格式一致。
- **服务器处理逻辑**：服务器对 HEAD 请求的处理流程与 GET 完全一致（例如权限校验、资源查找），唯一区别是最终不返回 body。

### 举例说明

- 用 GET 请求 `https://example.com/image.jpg`，服务器会返回响应头 + 图片的二进制数据（body），客户端可直接显示图片。
- 用 HEAD 请求 `https://example.com/image.jpg`，服务器仅返回响应头（如 `Content-Length: 204800` 表示图片大小为 200KB，`Content-Type: image/jpeg` 表示类型为 JPG），但不返回图片数据，适合快速判断图片是否存在及属性。

### 总结

HEAD 是 GET 的 “轻量版”，仅用于获取资源的元数据（头信息），不传输实际内容，适合高效检查资源状态；而 GET 用于获取完整资源内容。实际开发中，HEAD 常用于优化性能（减少无效数据传输），而 GET 是获取资源的标准方式。


## Get的请求参数可以写在body里吗

HTTP 规范中，**并没有明确禁止 GET 请求携带请求体（body）**，但从实际使用、协议语义和兼容性来看，**不建议将 GET 请求的参数放在 body 里**，原因如下：

### 1. 不符合 HTTP 方法的语义

GET 方法的设计初衷是 “获取资源”，其参数通常通过 URL 的查询字符串（`?key=value`）传递，这是 HTTP 协议对 GET 方法的 “约定语义”。而请求体（body）更多是为 POST、PUT 等用于 “提交 / 修改数据” 的方法设计的，用于携带复杂或大量数据。
将参数放在 GET 的 body 里，会违背这种语义约定，导致接口设计不直观。

### 2. 服务器和中间件的兼容性问题

大多数服务器（如 Nginx、Apache、Tomcat 等）和网络中间件（如代理服务器、负载均衡器）在处理 GET 请求时，**会忽略或不解析请求体中的内容**。
例如：

- 很多后端框架（如 Spring、Express）默认不会读取 GET 请求的 body 参数；
- 代理服务器可能会直接剥离 GET 请求的 body（认为其 “无效”），导致参数丢失。

### 3. 缓存机制失效

GET 请求通常是可缓存的（浏览器、CDN、代理服务器会缓存其响应），缓存的 key 通常基于 URL（包括查询字符串）。
如果参数放在 body 里，缓存系统无法识别 body 中的内容，会导致缓存失效（无法正确匹配相同参数的请求），违背了 GET 可缓存的设计初衷。

### 4. 客户端限制

大多数 HTTP 客户端（如浏览器、curl、Postman 等）在发送 GET 请求时，**默认不会携带 body**，甚至不支持为 GET 请求设置 body（例如浏览器的 XMLHttpRequest 或 fetch API，发送 GET 时设置 body 会被忽略或报错）。

### 结论

**不建议将 GET 请求的参数放在 body 里**。如果需要传递的参数较多、较复杂，或包含敏感信息，更适合使用 POST 方法（参数放在 body 中），而非强行使用 GET 并将参数放入 body。


## 设有两台机器A和B，他们之间通过TCP协议通信，B是服务器，A是客户端，现在B这台服务端突然宕机又很快重启了，而且重启后，它监听的IP和端口跟之前的完全不一样，对于客户端A来说，它并不知道B曾经宕机，那请问A和B还能继续原来的TCP通信吗？具体的TCP层面会经历什么过程

### 核心原因：TCP 连接的唯一标识是 “四元组”

TCP 连接通过**四元组**（源 IP、源端口、目的 IP、目的端口）唯一标识。客户端 A 与服务器 B 最初建立的连接，其标识为：
`(A的IP, A的端口, B原IP, B原端口)`

而服务器 B 重启后，监听的 IP 和端口已完全改变，新的标识变为：
`(A的IP, A的端口, B新IP, B新端口)`

由于四元组已完全不同，原有的 TCP 连接在协议层面已被 “销毁”―― 服务器 B 重启后，原连接的状态（如序号、窗口大小等）已丢失，且新监听的 IP 和端口与原连接无关。

### TCP 层面的具体过程

1. **客户端 A 的状态**：A 仍认为与 B 的原连接有效（因为 A 不知道 B 宕机重启），会继续发送数据（如应用层的请求）。这些数据的目的 IP 和端口仍是 B 原来的 IP 和端口。
2. **数据包的路由与接收**：
    - 若 B 原来的 IP 已不再属于任何设备（或被其他设备占用），A 发送的数据包会因 “目的不可达” 而丢失（可能触发 ICMP 错误，但 TCP 不直接处理 ICMP，仅感知超时）。
    - 即使 B 原来的 IP 仍存在（但 B 已换 IP），数据包也不会被新的 B 接收（因为 B 的新 IP 和端口与数据包的目的不符）。
3. **服务器 B 的状态**：B 重启后，仅监听新的 IP 和端口，对原连接的四元组无任何状态记录。因此，B**不会收到 A 发送的原连接数据**（因为数据的目的 IP / 端口与 B 当前监听的不符）。
4. **客户端 A 的超时与重传**：
    - A 发送数据后，长时间收不到 B 的确认（ACK），会触发 TCP 的超时重传机制，多次重传后仍失败。
    - 最终，客户端 A 的 TCP 层会判断连接异常（如超过最大重传次数），向上层（应用层）返回连接失败的错误（如 “连接超时”）。
5. **无法建立新通信**：即使 A 尝试向 B 的新 IP / 端口发送数据，也需要重新发起**三次握手**建立新连接（因为原四元组已无效），而非继续原来的通信。

### 结论

由于 TCP 连接依赖四元组唯一标识，且服务器 B 重启后改变了 IP 和端口，原连接的四元组失效，服务器也丢失了原连接的状态，因此 A 和 B 无法继续原来的 TCP 通信。原连接会因客户端超时失败而终止，若需通信，必须重新通过三次握手建立新连接。



## 讲一下HTTP有哪些常用请求头


### 1. **Host**

- **作用**：指定请求的服务器域名和端口号（HTTP/1.1 强制要求，用于在一台服务器上托管多个域名时区分目标站点）。
- **示例**：`Host: www.example.com` 或 `Host: api.example.com:8080`

### 2. **User-Agent**

- **作用**：告诉服务器客户端的类型（如浏览器、爬虫、应用程序等）及版本信息，服务器可据此返回适配的内容。

- 示例

  ：

    - 浏览器：`User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/116.0.0.0 Safari/537.36`
    - 爬虫：`User-Agent: curl/7.68.0`

### 3. **Accept**

- **作用**：指定客户端能接受的响应数据格式（媒体类型），服务器会优先返回匹配的格式。

- 示例

  ：

    - 接受 HTML 和 JSON：`Accept: text/html, application/json`
    - 接受所有类型：`Accept: */*`

### 4. **Accept-Encoding**

- **作用**：告知服务器客户端支持的压缩算法，服务器可通过压缩响应体减少传输量。
- **常用值**：`gzip`（GNU 压缩）、`deflate`（无损压缩）、`br`（Brotli 压缩）。
- **示例**：`Accept-Encoding: gzip, deflate, br`

### 5. **Accept-Language**

- **作用**：指定客户端能接受的自然语言（如中文、英文），服务器可据此返回对应语言的内容。
- **示例**：`Accept-Language: zh-CN, zh;q=0.9, en-US;q=0.8`（优先中文，其次英文，`q` 为权重）

### 6. **Content-Type**

- **作用**：当请求包含实体体（如 POST、PUT 请求）时，说明实体体的媒体类型（数据格式）。

- 常用值

  ：

    - 表单提交：`application/x-www-form-urlencoded`（默认，键值对格式）
    - 文件上传：`multipart/form-data`（用于带文件的表单）
    - JSON 数据：`application/json`
    - 纯文本：`text/plain`

- **示例**：`Content-Type: application/json`

### 7. **Content-Length**

- **作用**：当请求包含实体体时，指定实体体的字节长度（服务器可据此判断数据是否完整接收）。
- **示例**：`Content-Length: 1024`（表示实体体为 1024 字节）

### 8. **Authorization**

- **作用**：用于身份认证，向服务器提供认证信息（如账号密码、Token 等）。

- 常见类型

  ：

    - Basic 认证：`Authorization: Basic dXNlcjpwYXNzd29yZA==`（用户名：密码的 Base64 编码）
    - Bearer 认证（Token）：`Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...`（JWT 等令牌）

### 9. **Cookie**

- **作用**：客户端将服务器之前通过 `Set-Cookie` 响应头设置的 Cookie 信息回传给服务器（用于会话管理、身份识别等）。
- **示例**：`Cookie: sessionId=abc123; userId=456; theme=dark`

### 10. **Referer**

- **作用**：指示当前请求的来源页面 URL（即 “从哪个页面跳转到当前请求的 URL”）。
- **用途**：服务器可用于统计流量来源、防盗链等，但可能涉及隐私（部分场景会隐藏或不发送，如 HTTPS 页面跳转到 HTTP 页面）。
- **示例**：`Referer: https://www.baidu.com/s?wd=example`

### 11. **Cache-Control**

- **作用**：控制客户端的缓存策略（请求头中用于告知服务器客户端的缓存需求）。

- 常用值

  ：

    - `no-cache`：不直接使用缓存，需向服务器验证是否有效。
    - `no-store`：不缓存请求和响应（敏感数据常用）。
    - `max-age=0`：缓存立即过期，需重新请求。

- **示例**：`Cache-Control: no-cache`

### 12. **Accept-Charset**

- **作用**：指定客户端可接受的字符集（如 UTF-8、ISO-8859-1）。
- **示例**：`Accept-Charset: utf-8, iso-8859-1;q=0.5`

### 13. **Range**

- **作用**：用于 “断点续传”，请求资源的部分内容（而非完整资源）。
- **示例**：`Range: bytes=0-999`（请求资源的前 1000 字节）；`Range: bytes=500-`（请求从第 500 字节到末尾的内容）。
- **服务器响应**：若支持，返回 `206 Partial Content` 及对应部分内容。

### 14. **Origin**

- **作用**：跨域请求（如 AJAX）时，告知服务器请求的来源域名（用于 CORS 跨域资源共享验证）。
- **示例**：`Origin: https://www.otherdomain.com`（表示请求来自[otherdomain.com](https://otherdomain.com/)）

### 15. **If-Modified-Since**

- **作用**：条件请求头，配合服务器的 `Last-Modified` 响应头使用。客户端告知服务器：“如果资源在该时间后未修改，直接返回 304 Not Modified；否则返回新内容”（减少无效传输）。
- **示例**：`If-Modified-Since: Tue, 15 Nov 2022 12:45:26 GMT`

这些请求头是 HTTP 协议的核心组成部分，服务器通过解析它们可更精准地处理请求（如返回适配格式、验证身份、控制缓存等）。实际开发中，根据场景选择合适的请求头即可。


## token的篡改怎么解决

### 1. **核心机制：数字签名（Digital Signature）**

数字签名是防止 Token 篡改的最根本手段。其原理是：**Token 生成时，用密钥对 Token 内容进行签名；接收方验证时，用相同的密钥（或公钥）验证签名是否有效**。若 Token 被篡改，签名会失效，接收方即可拒绝该 Token。

#### 常见签名算法：

- **对称签名（HMAC）**：
  生成方和验证方使用**相同的密钥**（如 HMAC-SHA256）对 Token 内容进行签名和验证。
  适用场景：内部系统（如前后端同一服务、信任的服务间），密钥仅双方知晓。
- **非对称签名（RSA/ECC）**：
  生成方用**私钥**签名，接收方用对应的**公钥**验证（公钥可公开）。
  适用场景：跨系统（如第三方登录、开放平台），无需共享密钥，安全性更高。

### 2. **具体实现方式（以 JWT 为例）**

JWT（JSON Web Token）是最典型的可签名 Token 格式，其结构天然支持防篡改：
JWT = `Header（头部）.Payload（载荷）.Signature（签名）`

- **Header**：声明签名算法（如 `HS256` 即 HMAC-SHA256，`RS256` 即 RSA-SHA256）。
- **Payload**：存放核心信息（如用户 ID、过期时间 `exp`、权限等，**不建议放敏感信息**）。
- **Signature**：用 Header 声明的算法，结合密钥对 `Header.Base64 + "." + Payload.Base64` 进行签名。

接收方验证时，会重新计算签名并与 Token 中的 Signature 比对：

- 若一致：Token 未被篡改，有效；
- 若不一致：Token 被篡改，直接拒绝。

### 3. **辅助强化措施**

除了核心的签名机制，还需配合以下措施进一步降低风险：

#### （1）加密敏感信息（可选，但推荐）

签名仅保证**完整性**（未被篡改），但不保证**机密性**（内容可能被读取）。若 Token 包含敏感信息（如用户手机号），需对 Payload 进行加密（如 AES 对称加密），防止信息泄露被利用。

#### （2）设置短期有效期

即使 Token 未被篡改，长期有效的 Token 被窃取后风险更高。通过在 Token 中加入 `exp`（过期时间）字段，设置较短有效期（如 15 分钟），减少篡改后的有效攻击窗口。

- 配合**刷新 Token（Refresh Token）** 机制：短期访问 Token 过期后，用长期有效的 Refresh Token 申请新的访问 Token，平衡安全性和用户体验。

#### （3）传输层加密（HTTPS）

Token 在网络传输中可能被拦截篡改（如中间人攻击）。使用 HTTPS 加密传输通道，确保 Token 在传输过程中无法被窃听或修改（HTTPS 基于 TLS 协议，提供传输层的机密性和完整性）。

#### （4）避免在 Token 中存放可被利用的信息

即使签名有效，若 Token 中包含可被攻击者利用的信息（如角色权限 `role:admin`），攻击者可能通过其他方式（如替换合法 Token 的 Payload 并重新签名，若密钥泄露）伪造高权限 Token。因此：

- 仅存放必要信息（如用户 ID、过期时间）；
- 敏感权限逻辑在服务端验证（不依赖 Token 中的权限标识，而是查数据库确认）。

#### （5）严格的签名验证流程

接收方必须**强制验证签名**，不能跳过验证步骤（很多漏洞源于 “图方便” 跳过签名校验）。验证时需：

- 检查签名算法是否与预期一致（防止 “算法降级攻击”，如将 RSA 签名改为无签名的 `none` 算法）；
- 确保密钥安全（对称密钥不泄露，非对称私钥严格保管，公钥定期更新）。

#### （6）黑名单机制（应急处理）

若发现 Token 被篡改或泄露，可将其加入黑名单（如用 Redis 存储），即使签名有效，服务端也会拒绝该 Token。适用于：

- 短期 Token 过期前的紧急吊销；
- 密钥泄露后的应急处理（此时所有用旧密钥签名的 Token 均需失效）。

### 总结

防止 Token 篡改的**核心是数字签名**（确保 “被修改即无效”），辅以**加密（防泄露）、短期有效期（降风险）、HTTPS（防传输篡改）、严格验证（堵漏洞）** 等措施，形成完整的安全链条。其中，签名算法的选择、密钥管理、验证流程的严格性是关键，任何一环的疏漏都可能导致防护失效。