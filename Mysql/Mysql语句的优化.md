### select * from A where id in (select id from B)怎么优化

### **一、分析原查询的潜在问题**

原查询的执行逻辑是：先执行子查询 `SELECT id FROM B` 得到一个结果集（记为 `IDS`），再判断 `A.id` 是否在 `IDS` 中。若子查询返回的 `IDS` 过大，或 `A`/`B` 表未建立合适的索引，可能导致：



- 子查询全表扫描 `B` 表，耗时较长；
- 主查询对 `A` 表全表扫描，逐行判断 `id` 是否在 `IDS` 中（效率低，尤其 `A` 表较大时）；
- 子查询结果集过大，导致内存临时表或磁盘临时表的创建，增加 IO 开销。

### **二、优化方法**

#### **1. 为关联字段建立索引**

索引是提升查询效率的基础，优先确保：



- `B.id` 建立索引（加速子查询 `SELECT id FROM B` 的执行，减少扫描行数）；
- `A.id` 建立索引（若 `A` 表较大，主查询判断 `A.id IN (IDS)` 时可通过索引快速定位匹配记录，避免全表扫描）。



**示例**（MySQL）：



sql











```sql
-- 为B表id建索引（若B表id是主键，默认已建索引，可跳过）
CREATE INDEX idx_b_id ON B(id);
-- 为A表id建索引（若A表id是主键，默认已建索引，可跳过）
CREATE INDEX idx_a_id ON A(id);
```

#### **2. 将 `IN` 子查询改写为 `JOIN` 连接**

`IN` 子查询在很多场景下可改写为 `JOIN`，数据库优化器对 `JOIN` 的处理通常更灵活（可选择嵌套循环、哈希连接、合并连接等算法），尤其适合大表关联。



**改写注意**：`IN` 会自动去重（子查询返回重复 `id` 不影响结果），而 `JOIN` 可能因 `B` 表 `id` 重复导致 `A` 表记录重复，需用 `DISTINCT` 去重。



**改写示例**：



sql











```sql
-- 若B表id无重复，直接JOIN
SELECT A.* 
FROM A 
JOIN B ON A.id = B.id;

-- 若B表id有重复，需加DISTINCT确保结果与原查询一致
SELECT DISTINCT A.* 
FROM A 
JOIN B ON A.id = B.id;
```



**优势**：`JOIN` 可利用 `A.id` 和 `B.id` 的索引，通过索引快速匹配，减少全表扫描；优化器可根据表大小选择最优连接算法（如大表用哈希连接，小表用嵌套循环）。

#### **3. 改写为 `EXISTS` 子查询**

`EXISTS` 子查询的逻辑是 “存在即可”，一旦在 `B` 表中找到匹配的 `id`，就停止对 `B` 表的后续扫描，适合 `B` 表大但匹配记录少的场景。



**改写示例**：



sql











```sql
SELECT * 
FROM A 
WHERE EXISTS (
    SELECT 1 FROM B WHERE B.id = A.id  -- 用1代替*,减少不必要的字段读取
);
```



**优势**：



- `EXISTS` 子查询不关心 `B` 表返回的具体值（仅需判断 “是否存在”），因此 `SELECT 1` 比 `SELECT id` 更轻量；
- 对于 `A` 表的每一行，`EXISTS` 找到第一个匹配的 `B.id` 就终止扫描，减少 `B` 表的 IO 开销（尤其 `B` 表有索引时）。

#### **4. 优化子查询结果集大小**

若 `B` 表数据量大，可通过过滤条件减少子查询返回的 `id` 数量，从源头降低主查询的匹配压力。



**示例**：若仅需 `B` 表中 `status=1` 的 `id`，则子查询应增加过滤：



sql











```sql
-- 原查询优化
SELECT * FROM A WHERE id IN (SELECT id FROM B WHERE status = 1);

-- 对应JOIN优化
SELECT DISTINCT A.* FROM A JOIN B ON A.id = B.id WHERE B.status = 1;
```



**关键**：给 `B` 表的过滤字段（如 `status`）建立联合索引（如 `(status, id)`），使子查询可通过索引完成过滤 + 取值，无需回表扫描。

#### **5. 避免 `SELECT \*`，只查询必要字段**

`SELECT *` 会读取表中所有字段，可能导致：



- 无法利用覆盖索引（若查询字段均可通过索引获取，无需回表）；
- 增加数据传输和内存开销（尤其大表或字段多的表）。



**优化示例**：若只需 `A` 表的 `id` 和 `name`，则明确指定：



sql











```sql
SELECT id, name FROM A WHERE id IN (SELECT id FROM B);
```



若 `A` 表有联合索引 `(id, name)`，则主查询可通过索引直接返回结果，无需访问表数据（覆盖索引优化）。

#### **6. 分析执行计划，针对性优化**

使用数据库的 `EXPLAIN` 命令分析原查询和优化后的查询，重点关注：



- `type` 列：是否为 `range`（范围扫描）、`ref`（索引匹配）或 `eq_ref`（唯一索引匹配），避免 `ALL`（全表扫描）；
- `key` 列：是否用到预期的索引；
- `rows` 列：估计扫描的行数，数值越小越好；
- `Extra` 列：是否有 `Using filesort`（文件排序）、`Using temporary`（临时表）等低效操作。



**示例（MySQL）**：



sql











```sql
EXPLAIN SELECT * FROM A WHERE id IN (SELECT id FROM B);
```



根据执行计划调整索引或改写逻辑（如出现 `Using temporary`，可能需要增加索引或用 `JOIN` 避免临时表）。

### **三、不同场景下的最优选择**

| 场景                           | 推荐优化方式                | 原因                                                       |
| ------------------------------ | --------------------------- | ---------------------------------------------------------- |
| `B` 表小，`A` 表大且有索引     | `IN` 或 `EXISTS`            | 子查询结果集小，`IN` 效率高；`EXISTS` 可快速匹配停止扫描。 |
| `B` 表大，`A` 表大             | `JOIN`（带 `DISTINCT`）     | 优化器可选择哈希连接等高效算法，适合大表关联。             |
| `B` 表有重复 `id`              | `JOIN + DISTINCT` 或 `IN`   | 确保结果去重，与原查询一致。                               |
| `B` 表有过滤条件（如 `where`） | 子查询加过滤条件 + 联合索引 | 减少子查询结果集，通过索引快速过滤和取值。                 |

### **总结**

优化 `IN` 子查询的核心思路是：**减少扫描行数**（通过索引）、**优化关联方式**（`JOIN` 或 `EXISTS`）、**缩小结果集**（过滤条件）。实际优化中需结合执行计划和表数据特征（大小、索引情况）选择最合适的方法。