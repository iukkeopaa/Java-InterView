## 代码实现


```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource;
import org.springframework.transaction.annotation.EnableTransactionManagement;
import javax.sql.DataSource;
import java.util.HashMap;
import java.util.Map;

// 配置类：数据源配置
@Configuration
@EnableTransactionManagement
public class DataSourceConfig {

    // 主库数据源（写操作）
    @Bean("masterDataSource")
    public DataSource masterDataSource() {
        // 实际项目中使用数据库连接池，如 HikariCP
        org.apache.tomcat.jdbc.pool.DataSource dataSource = new org.apache.tomcat.jdbc.pool.DataSource();
        dataSource.setDriverClassName("com.mysql.cj.jdbc.Driver");
        dataSource.setUrl("jdbc:mysql://master-host:3306/mydb");
        dataSource.setUsername("root");
        dataSource.setPassword("password");
        return dataSource;
    }

    // 从库数据源（读操作）
    @Bean("slaveDataSource")
    public DataSource slaveDataSource() {
        org.apache.tomcat.jdbc.pool.DataSource dataSource = new org.apache.tomcat.jdbc.pool.DataSource();
        dataSource.setDriverClassName("com.mysql.cj.jdbc.Driver");
        dataSource.setUrl("jdbc:mysql://slave-host:3306/mydb");
        dataSource.setUsername("root");
        dataSource.setPassword("password");
        return dataSource;
    }

    // 动态路由数据源
    @Bean
    public DataSource routingDataSource() {
        DynamicRoutingDataSource routingDataSource = new DynamicRoutingDataSource();
        
        Map<Object, Object> targetDataSources = new HashMap<>();
        targetDataSources.put(DataSourceType.MASTER, masterDataSource());
        targetDataSources.put(DataSourceType.SLAVE, slaveDataSource());
        
        routingDataSource.setDefaultTargetDataSource(masterDataSource());
        routingDataSource.setTargetDataSources(targetDataSources);
        return routingDataSource;
    }
}

// 动态数据源路由实现
public class DynamicRoutingDataSource extends AbstractRoutingDataSource {
    @Override
    protected Object determineCurrentLookupKey() {
        return DataSourceContextHolder.getDataSource();
    }
}

// 数据源类型枚举
public enum DataSourceType {
    MASTER, SLAVE
}

// 数据源上下文持有者（使用 ThreadLocal 存储当前线程的数据源）
public class DataSourceContextHolder {
    private static final ThreadLocal<DataSourceType> contextHolder = new ThreadLocal<>();

    public static void setDataSource(DataSourceType dataSource) {
        contextHolder.set(dataSource);
    }

    public static DataSourceType getDataSource() {
        return contextHolder.get();
    }

    public static void clearDataSource() {
        contextHolder.remove();
    }
}

// 数据源切换注解
import java.lang.annotation.*;

@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface DataSource {
    DataSourceType value() default DataSourceType.MASTER;
}

// 数据源切面
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.After;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.reflect.MethodSignature;
import org.springframework.core.annotation.AnnotationUtils;
import org.springframework.stereotype.Component;
import java.lang.reflect.Method;

@Aspect
@Component
public class DataSourceAspect {

    @Before("@annotation(com.example.demo.DataSource) || @within(com.example.demo.DataSource)")
    public void before(JoinPoint point) {
        Class<?> targetClass = point.getTarget().getClass();
        DataSourceType dataSourceType = DataSourceType.MASTER;

        // 类级别注解
        DataSource classAnnotation = AnnotationUtils.findAnnotation(targetClass, DataSource.class);
        if (classAnnotation != null) {
            dataSourceType = classAnnotation.value();
        }

        // 方法级别注解（覆盖类级别）
        MethodSignature signature = (MethodSignature) point.getSignature();
        Method method = signature.getMethod();
        DataSource methodAnnotation = method.getAnnotation(DataSource.class);
        if (methodAnnotation != null) {
            dataSourceType = methodAnnotation.value();
        }

        DataSourceContextHolder.setDataSource(dataSourceType);
    }

    @After("@annotation(com.example.demo.DataSource) || @within(com.example.demo.DataSource)")
    public void after(JoinPoint point) {
        DataSourceContextHolder.clearDataSource();
    }
}

// 使用示例
@Service
public class UserService {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    // 默认使用主库（写操作）
    public void createUser(String username) {
        String sql = "INSERT INTO users (username) VALUES (?)";
        jdbcTemplate.update(sql, username);
    }

    // 显式指定从库（读操作）
    @DataSource(DataSourceType.SLAVE)
    public List<Map<String, Object>> getUsers() {
        String sql = "SELECT * FROM users";
        return jdbcTemplate.queryForList(sql);
    }
}
```

# ?什么是读写分离？如何实现？

# 典型回答


在分布式系统设计中，读写分离是一种常见的架构模式，可以提升系统的处理能力、扩展性和可用性。简单来说就是分开处理读和写操作。



+ **读操作**：通常指的是从数据库中检索数据的操作，比如 SQL 查询。
+ **写操作**：包括创建、更新或删除数据库中的数据，比如 SQL 的 INSERT、UPDATE、DELETE 语句。

<font style="color:rgb(13, 13, 13);"></font>

读写分离的好处：

1. **提高性能**：**一般来说，大型分布式应用中都是读多写少的**。将读写操作分离可以显著提高数据库系统的整体性能。
2. **提高可扩展性**：读写分离允许系统按需增加从数据库实例，以应对读请求量的增长，从而提高系统的可扩展性。
3. **增加可用性和容错性**：在主-从复制架构中，如果主数据库出现故障，可以从从数据库中选举或提升一个为新的主数据库，从而减少系统的停机时间。
4. **负载均衡**：通过在多个从数据库之间分散读请求，可以实现负载均衡，避免单个数据库的过载，从而提高系统的响应速度和稳定性。

<font style="color:rgb(13, 13, 13);"></font>

我们都知道MySQL提供了主从复制的能力，所以我们就可以基于MySQL自带的主从复制的能力来实现读写分离。



[?MySQL主从复制的过程](https://www.yuque.com/hollis666/xkm7k3/hoi4ql)



在这种模式下，写操作只在主数据库（Master）上执行，而读操作则可以在从数据库（Slave）上执行。主库和从库通过主从复制来保持数据的同步。



![1712213393232-545a9d60-95ac-4850-a675-18e5a777644c.png](./img/bpdiMa3P7f8-xN9x/1712213393232-545a9d60-95ac-4850-a675-18e5a777644c-311090.png)



在通过主从复制实现读写分离的架构中，从库可以是一个，也可以是多个。也就是说可以是一主一从、也可以是一主多从。



## 如何做读写的分流？


如何实现让写流量请求到主库，读流量请求到从库呢，这就涉及到具体的读写分流了。



一般来说，首先我们需要把接口从定义上或者从职责上划分清楚，读接口和写接口。如UserReadService就是专门负责提供读服务的，UserWriteService就是专门负责写服务的。



接下来，ReadService在操作的时候，只需要和从库进行交互，而WriteServie在操作的时候只需要和主库进行操作就行了。具体分流方式有以下集中：



### 1、代码分流


最简单直观的方式，就是我们自己编码实现，我们可以在DAO层定义多个数据源，然后在实际进行读或者写操作的时候，选择使用不同的数据源即可。



如以下方式定义两个不同的DataSource：



```java
@Configuration
public class DataSourceConfig {

    @Bean
    @Primary
    public DataSource primaryDataSource() {
        // 配置主数据源
        return DataSourceBuilder.create().url("jdbc:mysql://master_db:3306/mydb").username("user").password("pass").build();
    }

    @Bean
    public DataSource replicaDataSource() {
        // 配置从数据源
        return DataSourceBuilder.create().url("jdbc:mysql://replica_db:3306/mydb").username("user").password("pass").build();
    }
}
```



在定义一个动态数据源：



```java
public class DynamicDataSource extends AbstractRoutingDataSource {
    @Override
    protected Object determineCurrentLookupKey() {
        // 你可以根据实际情况来决定使用哪个数据源
        return DbContextHolder.getDbType();
    }
}
```



在 Spring 配置中设置 DynamicDataSource，并将之前定义的主从数据源作为目标数据源。



```java
@Configuration
public class RoutingConfig {

    @Autowired
    @Qualifier("primaryDataSource")
    private DataSource primaryDataSource;

    @Autowired
    @Qualifier("replicaDataSource")
    private DataSource replicaDataSource;

    @Bean
    public DataSource dataSource() {
        DynamicDataSource dynamicDataSource = new DynamicDataSource();
        Map<Object, Object> targetDataSources = new HashMap<>();
        targetDataSources.put(DbType.MASTER, primaryDataSource);
        targetDataSources.put(DbType.SLAVE, replicaDataSource);
        dynamicDataSource.setTargetDataSources(targetDataSources);
        dynamicDataSource.setDefaultTargetDataSource(primaryDataSource); // 默认使用主数据源
        return dynamicDataSource;
    }
}
```



<font style="color:rgb(13, 13, 13);">通过 AOP 在业务层或 DAO 层方法调用前动态切换数据源。可以基于注解或方法名称约定来拦截方法调用。针对find方法使用从库，针对insert方法使用主库。</font>

<font style="color:rgb(13, 13, 13);"></font>

```java
@Aspect
@Component
public class DataSourceAspect {

    @Before("execution(* com.example.repository..*.find*(..)) || execution(* com.example.repository..*.get*(..))")
    public void setReadDataSourceType() {
        DbContextHolder.setDbType(DbType.SLAVE);
    }

    @Before("execution(* com.example.repository..*.insert*(..)) || execution(* com.example.repository..*.update*(..))")
    public void setWriteDataSourceType() {
        DbContextHolder.setDbType(DbType.MASTER);
    }

    @After("execution(* com.example.repository..*.*(..))")
    public void clearDataSourceType() {
        DbContextHolder.clearDbType();
    }
}


public class DbContextHolder {

    private static final ThreadLocal<DbType> contextHolder = new ThreadLocal<>();

    public static void setDbType(DbType dbType) {
        contextHolder.set(dbType);
    }

    public static DbType getDbType() {
        return contextHolder.get();
    }

    public static void clearDbType() {
        contextHolder.remove();
    }

    public enum DbType {
        MASTER, SLAVE
    }
}

```

