## 表缺乏主键或者索引

当binlog的存储格式为row的情况下，如果表缺乏主键或索引，在执行UPDATE、DELETE的时候可能会造成从库延迟骤增。

比如，订单order表有1000万的数据，根据order_num更新status时，如果没有order_num的单索引或者联合索引，主库更新会全表扫描，因此执行时间较长，比如30s。

```sql
sql

 体验AI代码助手
 代码解读
复制代码update order set status = 1 where order_num ='1';
```

虽然I/O线程能够迅速从主库中读取到update操作，但是Slave节点的SQL线程从ReplayLog中读取到update语句，并进行重播，由于全表扫描，因此，同样延迟30s执行，主库和从库就产生了较长时间的延迟。

此外，还有一个更特殊而普遍的情况:`主库产生的日志记在binlog里是row格式的，不是一条sql，而是这条sql所影响的具体值的修改。主库执行一条sql修改了2万行，只需要全表扫描一次，但是，备库就要执行2万条sql语句，全表扫描2万次`

显而易见，解决办法就是：`创建主键或者索引，避免全表扫描。`


## 主库DML请求频繁

解决思路：如果是MySQL 5.7以下的版本，可以做分片(sharding)，通过水平扩展(scale out)的方法打散写请求，提升写请求写入binlog的并行度。

如果是MySQL 5.7以上的版本，在MySQL 5.7，使用了基于逻辑时钟(Group Commit)的并行复制。而在MySQL 8.0，使用了基于Write Set的并行复制。这两种方案都能够提升回放binlog的性能，减少延时。



## 主库写binlog不及时

参数sync_binlog控制binlog从内存写入磁盘的控制开关，5.6默认为0，从5.7开始默认为1。

sync_binlog=1：每次事务提交都立即刷新binlog到磁盘(双一标准中的其一)。

sync_binlog=0：每次事务提交不立即写入磁盘，靠操作系统判断什么时候写入。

磁盘IO不行，binlog写入比较慢。建议binlog使用ssd。

## 主库执行大事务

大事务指一个事务的执行，耗时非常长。常见产生大事务的语句有： 使用了大量速度很慢的导入数据语句，比如：INSERT INTO 、tb、LOAD DATA INFILE等； 使用了UPDATE、DELETE语句，对于一个很大的表进行全表的UPDATE和DELETE等。 当这个事务在从库执行回放执行操作时，就有可能会产生主从复制延时。

解决办法：拆分大事务语句到若干小事务中，这样能够进行及时提交，减小主从复制延时。


## 主库对大表执行DDL语句

DDL全称为 Data Definition Language ，指一些对表结构进行修改操作的语句，比如，对表加一个字段或者加一个索引等等。当DDL对主库大表执行DDL语句的情况下，可能会产生主从复制延时。DDL导致的主从复制延时的原因和大事务类似，也是因为从库执行DDL的binlog较慢而产生了主从复制延时。

遇到这种情况，我们主要通过SHOW PROCESSLIST或对information_schema.innodb_trx做查询，来找到阻塞DDL语句，并KILL掉相关查询，让DDL正常在从库执行。

## 主库与从库配置不一致

如果主库和从库使用了不同的计算资源和存储资源，或者使用了不同的内核调教参数，可能会造成主从不一致。

各种硬件或者资源的配置差异都有可能导致主从的性能差异，从而导致主从复制延时发生：

硬件上：比如，主库实例服务器使用SSD磁盘，而从库实例服务器使用普通SAS盘，那么主库产生的写入操作在从库上不能马上消化掉，就产生了主从复制延时；

配置上：比如，RAID卡写策略不一致、OS内核参数设置不一致、MySQL落盘策略不一致等，都是可能的原因。

解决思路：考虑尽量统一DB机器的配置（包括硬件及选项参数）。甚至对于某些OLAP业务，从库实例硬件配置需要略高于主库。

## 从库自身压力过大

从库执行大量select请求，或业务大部分select请求被路由到从库实例上，甚至大量OLAP业务，或者从库正在备份等。 此时可能造成cpu负载过高，io利用率过高等，导致SQL Thread应用过慢、



## 强制走主库方案

```plaintext
降低多线程大事务并发的概率，优化业务逻辑

优化SQL，避免慢SQL，减少批量操作，建议写脚本以update-sleep这样的形式完成。

提高从库机器的配置，减少主库写binlog和从库读binlog的效率差。

尽量采用短的链路，也就是主库和从库服务器的距离尽量要短，提升端口带宽，减少binlog传输的网络延时。

实时性要求的业务读强制走主库，从库只做灾备，备份
```


# 解决方法的参考

主从延迟是分布式数据库架构中（如 MySQL、PostgreSQL 等）常见的问题，本质是**主库写入数据后，从库通过复制机制同步数据的过程中产生的时间差**。延迟的核心原因包括：网络传输耗时、从库 SQL 线程执行慢、主库写入压力过大、大事务累积等。解决主从延迟需要从**复制机制优化、硬件资源、SQL 与事务设计、架构调整**等多维度入手，以下是具体方案：

### 一、优化复制机制（核心手段）

#### 1. 升级复制协议：从异步→半同步 / 全同步复制

- **异步复制**（默认）：主库写入 binlog 后立即返回，不等待从库确认，延迟风险最高。
- **半同步复制**：主库写入 binlog 后，等待至少 1 个从库接收并确认 binlog（不等待从库执行）再返回，大幅降低延迟窗口（需 MySQL 5.5 + 支持，配置`rpl_semi_sync_master_enabled=1`）。
- **全同步复制**：主库等待从库完全执行完 binlog 后再返回，延迟接近 0，但主库性能会受影响（适合对一致性要求极高的场景，如金融核心交易）。

#### 2. 启用并行复制（从库多线程同步）

从库同步慢的主要瓶颈是**单线程执行 SQL**（传统复制中，从库的 IO 线程负责拉取 binlog，SQL 线程单线程执行）。启用并行复制可让从库多线程并行执行 binlog，提升同步速度：



- MySQL

  ：

    - 5.6+ 支持**基于库的并行复制**（按库分线程，适合多库场景）。
    - 5.7+ 支持**基于 GTID 的并行复制**（按事务组并行，更高效，需开启`slave-parallel-type=LOGICAL_CLOCK`）。
    - 8.0+ 进一步优化并行复制，默认启用多线程，且支持 “write-set” 并行（基于事务冲突检测）。

- **PostgreSQL**：通过`hot_standby_feedback`减少冲突，或使用`pg_stat_replication`监控延迟，结合`max_worker_processes`配置并行应用 WAL 日志。

#### 3. 优化 binlog 传输效率

- **压缩 binlog**：主库启用 binlog 压缩（如 MySQL 的`binlog_compress=1`），减少网络传输量。
- **减少 binlog 体积**：避免主库写入大量无用日志（如关闭不需要的 binlog 格式，或通过`binlog_do_db`/`binlog_ignore_db`过滤无关库）。
- **使用专用网络**：主从节点部署在同一机房，或使用低延迟专线，避免跨地域网络波动（如跨 IDC 的主从延迟通常较高）。

### 二、优化从库性能（提升同步执行速度）

#### 1. 提升从库硬件配置

从库的 SQL 线程执行效率依赖硬件，若从库 CPU、内存、磁盘 IO 不足，会导致同步卡顿：



- 配置与主库相当的 CPU（避免从库 CPU 核心数远低于主库）。
- 增加从库内存，确保足够缓存（如 InnoDB buffer pool），减少磁盘 IO。
- 从库使用 SSD 硬盘，提升随机读写速度（尤其适合频繁更新的场景）。

#### 2. 减少从库负载

从库若同时承担大量读请求，会占用 CPU/IO 资源，导致 SQL 线程执行缓慢：



- **读写分离优化**：通过中间件（如 MyCat、ShardingSphere）将读请求分流到多个从库，避免单个从库过载。
- **从库只读化**：禁止在从库执行写操作（除同步外），避免写操作与同步线程竞争资源。
- **限制从库查询复杂度**：禁止在从库执行大表全表扫描、复杂 JOIN 等耗时查询，必要时将复杂查询迁移到分析型数据库（如 ClickHouse）。

### 三、优化主库与事务设计（减少延迟源头）

#### 1. 控制主库写入压力

主库写入过于频繁（如高并发插入、批量更新）会导致 binlog 生成堆积，从库同步滞后：



- **批量写入优化**：将高频小事务合并为批量事务（如`insert into ... values (...), (...), ...`），减少事务数量。
- **限流削峰**：通过应用层或中间件限制主库写入 QPS，避免瞬间流量压垮主库（如使用 Redis 做写入缓冲，异步批量同步到 DB）。

#### 2. 避免大事务

大事务（如一次性更新 10 万行数据）会导致：



- 主库生成巨大的 binlog，传输耗时增加；
- 从库执行该事务时需长时间锁定资源，阻塞后续同步。



**优化方案**：



- 将大事务拆分为多个小事务（如按批次更新，每批 1000 行）。
- 避免在事务中执行无关操作（如查询、日志打印），缩短事务持有时间。

#### 3. 优化 SQL 与索引

主库执行的 SQL 若效率低，会导致 binlog 生成慢，且从库执行时同样耗时：



- 为主库的高频写入 / 更新语句添加合适索引，减少主库执行时间。
- 避免使用`SELECT ... FOR UPDATE`等长事务锁，减少主库阻塞。

### 四、架构层面调整（规避延迟影响）

#### 1. 读写分离策略优化

对实时性要求极高的读请求（如用户刚提交的订单），强制路由到主库；非实时性请求（如历史订单查询）路由到从库：



- 在应用层增加判断逻辑（如 “5 秒内的新数据读主库”）。
- 使用中间件（如 ProxySQL）自动检测主从延迟，当延迟超过阈值（如 1 秒）时，将读请求转发到主库。

#### 2. 多从库与级联复制

- **多从库分担读压力**：主库连接多个从库，通过负载均衡（如 LVS、HAProxy）分配读请求，避免单个从库过载。
- **级联复制**：主库→中间从库→从库，减少主库直接连接的从库数量，降低主库 binlog 传输压力（中间从库需开启`log_slave_updates`）。

#### 3. 采用混合复制模式

- 对核心业务使用**半同步复制**（确保数据不丢失），非核心业务使用**异步复制**（降低主库压力）。
- 引入分布式数据库（如 Spanner、TiDB），其原生支持强一致性复制，减少主从延迟问题。

### 五、监控与应急处理

#### 1. 实时监控延迟

- 监控指标：MySQL 的`Seconds_Behind_Master`（从库延迟秒数）、`binlog`文件差距；PostgreSQL 的`replay_lag`。
- 工具：Prometheus+Grafana（可视化监控）、Percona Monitoring and Management（PMM）。

#### 2. 应急处理

- 若延迟突增，临时停止从库的读请求，让其全力同步数据。
- 必要时重建从库（当从库数据损坏或延迟过大时，通过`mysqldump`或`xtrabackup`快速重建）。

### 总结

主从延迟的解决需结合**复制机制优化（如半同步、并行复制）、硬件升级、SQL 与事务设计、架构调整**等多方面，核心思路是：**减少主库写入压力→提升从库同步速度→规避延迟对业务的影响**。实际应用中需根据业务场景（如实时性要求、数据量）选择合适方案，同时通过监控及时发现并处理异常延迟。


