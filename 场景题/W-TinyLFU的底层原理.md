### 为什么需要 W-TinyLFU？

传统缓存淘汰算法存在明显局限：

- **LRU（最近最久未使用）**：仅关注元素的 “访问时间”，容易淘汰掉 “不常访问但总访问次数极高” 的元素（比如每日固定时段高频访问的周期性数据）。
- **LFU（最近最少使用）**：仅关注元素的 “访问频率”，但对 “新进入的元素” 不友好（冷启动问题），且容易被 “突发的短期高频访问” 污染（比如一次热点事件导致大量临时元素占据缓存，挤走长期有用的元素）。

W-TinyLFU 的设计目标就是解决这些问题，兼顾 “新元素的短期价值” 和 “旧元素的长期频率价值”。

### W-TinyLFU 的核心组成

W-TinyLFU 由三个关键部分组成，协同工作实现高效的缓存淘汰：

#### 1. Window Cache（窗口缓存）

- **作用**：临时存储 “最近刚访问的新元素”，避免新元素被立即淘汰（解决 LFU 的冷启动问题）。
- **策略**：采用 LRU 策略管理，容量通常为总缓存的 10%。
- **原理**：新元素首先进入 Window Cache，若在窗口内被再次访问，说明它可能具有短期价值；若窗口满了，会将其中 “最久未访问” 的元素迁移到 Main Cache（或淘汰）。

#### 2. Main Cache（主缓存）

- **作用**：存储 “经过验证的高频访问元素”，保留长期价值高的元素。
- **策略**：采用 LFU 策略管理，容量为总缓存的 90%。
- **原理**：从 Window Cache 迁移过来的元素，会在这里根据 “访问频率” 竞争生存空间 ―― 频率越高的元素，被淘汰的概率越低。

#### 3. TinyLFU Filter（TinyLFU 过滤器）

- **作用**：轻量级的 “频率评估器”，防止 “低频元素” 进入或污染 Main Cache（解决 LFU 的缓存污染问题）。

- **实现**：基于**Count-Min Sketch**数据结构（一种空间高效的概率性数据结构），用极小的内存（通常每个元素几比特）记录所有元素的访问频率估算值。

- 工作流程

  ：

  当新元素需要进入 Main Cache（或从 Window Cache 迁移过来）时，TinyLFU 会比较该元素的频率与 Main Cache 中 “频率最低的元素” 的频率：

    - 若新元素频率更高，则允许进入（替换低频元素）；
    - 若新元素频率更低，则被过滤掉（不允许进入，避免污染）。

### W-TinyLFU 的工作流程（简化）

1. **新元素访问**：首次访问的元素先进入 Window Cache（LRU 管理）。
2. **窗口内验证**：若元素在 Window Cache 中被再次访问，说明有短期价值；若窗口满，最久未访问的元素会被评估是否进入 Main Cache。
3. **过滤与迁移**：待迁移元素需通过 TinyLFU 过滤器 ―― 只有其频率高于 Main Cache 中最低频元素时，才能进入 Main Cache（LFU 管理），否则直接淘汰。
4. **主缓存维护**：Main Cache 中，频率低的元素会逐渐被频率高的元素替换；同时，TinyLFU 会定期衰减所有元素的频率（避免 “历史高频” 元素永久占据缓存）。

### W-TinyLFU 的核心优势

1. **抗缓存污染**：通过 TinyLFU 过滤器，有效阻挡短期突发访问的低频元素进入主缓存。
2. **兼顾新老元素**：Window Cache 给新元素 “试错机会”，Main Cache 保留长期高频元素，平衡了 “时效性” 和 “频率性”。
3. **内存高效**：TinyLFU 基于 Count-Min Sketch，用极小内存（约每元素 1-2 比特）实现频率估算，适合大容量缓存。
4. **高命中率**：在多样化访问模式（如混合突发流量、周期性访问）下，命中率显著高于 LRU 或纯 LFU。

### 总结

W-TinyLFU 是 Caffeine 的 “核心武器”，它通过 “Window Cache（短期 LRU）+ Main Cache（长期 LFU）+ TinyLFU 过滤器（频率校验）” 的三层架构，解决了传统算法的冷启动、缓存污染等问题，使其在高并发场景下（如分布式系统、微服务缓存）表现卓越。这也是 Caffeine 在性能测试中常超越 Guava Cache、EHCache 等工具的关键原因之一。


LFU 通常能带来最佳的缓存命中率，但 LFU 有两个缺点：

1. 它需要给每个记录项维护频率信息，每次访问都需要更新，需要一个巨大的空间记录所有出现过的 key 和其对应的频次；
2. 如果数据访问模式随时间有变，LFU 的频率信息无法随之变化，因此早先频繁访问的记录可能会占据缓存，而后期访问较多的记录则无法被命中；
3. 如果一个刚加入缓存的元素，它的频率并不高，那么它可能会会直接被淘汰。