### 一、哈希分表（Hash Sharding）

**核心思想**：通过哈希函数将数据均匀分布到多个表中，确保数据负载均衡。
**常见实现**：

1. **取模法**（最基础）
    - 公式：`table_index = hash(key) % table_count`
    - 示例：用户 ID 为 100，分 4 张表，则 `100 % 4 = 0`，数据存入表 0。
    - **优点**：实现简单，数据分布均匀。
    - **缺点**：扩表时需重新计算哈希（如从 4 张表扩到 5 张，大部分数据需迁移）。
2. **一致性哈希**
    - 通过虚拟节点解决扩表时的数据迁移问题，新增表只需影响部分虚拟节点。
    - **优点**：扩表时只需迁移少量数据。
    - **缺点**：实现较复杂，需维护虚拟节点与物理表的映射关系。

**适用场景**：对数据分布均匀性要求高，且查询模式多为单条记录访问（如用户中心、订单系统）。

### 二、范围分表（Range Sharding）

**核心思想**：按数据的某个范围字段（如时间、ID 区间）划分表。
**常见实现**：

1. **按时间分表**
    - 示例：按年 / 月分表（如`orders_202301`、`orders_202302`）。
    - **优点**：历史数据与近期数据分离，便于归档和查询。
    - **缺点**：可能导致热点问题（如近期表访问压力大）。
2. **按 ID 区间分表**
    - 示例：用户 ID 1~10000 存入表 1，10001~20000 存入表 2。
    - **优点**：适合顺序访问（如批量查询）。
    - **缺点**：数据分布可能不均（如 ID 生成规则导致部分区间数据密集）。

**适用场景**：时间序列数据（如日志、监控数据）、按区间批量查询的场景。

### 三、按业务字段分表（Field-Based Sharding）

**核心思想**：根据业务逻辑字段（如地区、用户类型）划分表。
**常见实现**：

1. **按地区分表**
    - 示例：华北用户数据存入`users_north`，华南用户存入`users_south`。
    - **优点**：符合业务地域隔离需求，减少跨区域访问。
    - **缺点**：可能导致数据分布不均（如某些地区用户多）。
2. **按用户类型分表**
    - 示例：VIP 用户存入`users_vip`，普通用户存入`users_normal`。
    - **优点**：优化特定业务类型的查询效率。
    - **缺点**：需提前规划业务类型，扩展性较差。

**适用场景**：有明确业务隔离需求（如多租户系统、地域化服务）。

### 四、复合分表（Hybrid Sharding）

**核心思想**：结合多种分表算法，平衡性能和灵活性。
**常见实现**：

1. **哈希 + 范围**
    - 先按时间范围分表（如按年），再对每个表内数据哈希分表。
    - 示例：2023 年数据存入`orders_2023`，再对`orders_2023`内数据哈希分 4 张表。
    - **优点**：兼顾时间查询和数据均匀分布。
    - **缺点**：实现复杂度高。
2. **业务字段 + 哈希**
    - 先按地区分表，再对每个地区表内数据哈希分表。
    - **优点**：解决单字段分表的热点问题。
    - **缺点**：需维护多级路由规则。

**适用场景**：数据量大且查询模式复杂（如同时需要按时间和用户 ID 查询）。

### 五、预计算分表（Precomputed Sharding）

**核心思想**：根据业务规则预先计算分表规则，无需实时计算哈希。
**常见实现**：

1. **业务规则映射**
    - 示例：用户 ID 1~10000 固定存入表 1，10001~20000 存入表 2（通过配置文件或规则引擎映射）。
    - **优点**：查询时无需计算，直接定位表。
    - **缺点**：扩表时需修改映射规则，不够灵活。
2. **查表法**
    - 通过一个 “路由表” 记录数据与表的映射关系（如用户 ID→表名）。
    - **优点**：灵活，可动态调整。
    - **缺点**：每次查询需先访问路由表，增加一次 IO。

**适用场景**：数据分布不均，但业务规则明确（如按用户等级分表）。

### 六、动态分表（Adaptive Sharding）

**核心思想**：根据实时负载自动调整分表策略（如自动拆分热点表）。
**常见实现**：

1. **基于数据库中间件**
    - 如 ShardingSphere、MyCat 等中间件支持动态扩容，自动迁移数据。
    - **优点**：对业务透明，无需手动干预。
    - **缺点**：依赖中间件，引入额外运维成本。
2. **冷热数据分离**
    - 定期将冷数据迁移到历史表，热数据保留在当前表。
    - **优点**：优化热点表性能。
    - **缺点**：需定期执行数据迁移任务。

**适用场景**：数据访问模式波动大，需动态优化的场景。

### 七、分表算法选择建议

| 场景                   | 推荐算法           |
| ---------------------- | ------------------ |
| 数据均匀分布，单条查询 | 哈希分表           |
| 时间序列数据，批量查询 | 范围分表（按时间） |
| 业务隔离需求           | 按业务字段分表     |
| 复杂查询模式           | 复合分表           |
| 动态负载               | 动态分表           |

### 八、分表需注意的问题

1. **跨表查询**：分表后无法直接 JOIN，需通过应用层聚合或分布式查询解决。
2. **主键生成**：需全局唯一 ID（如 UUID、雪花算法 Snowflake）。
3. **数据迁移**：扩表时可能需迁移历史数据，需谨慎设计。
4. **事务一致性**：跨表事务需通过柔性事务（如 TCC、Saga）或最终一致性保证。

选择分表算法时，需综合考虑数据量、查询模式、扩展性、运维成本等因素，必要时结合数据库中间件（如 ShardingSphere、Vitess）实现自动化管理。