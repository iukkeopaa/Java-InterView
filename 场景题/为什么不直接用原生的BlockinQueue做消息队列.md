# 典型回答

直接使用原生的 `BlockingQueue` 来做消息队列在某些场景下是可以的，但是非常不建议，因为它存在以下几个问题：

### 1. 缺乏分布式特性

`BlockingQueue` 是一个本地队列，无法在多个节点之间共享数据。可能会存在单机瓶颈以及流量倾斜，比如某台机器的任务比较多，但是其他的机器却没有啥任务要执行。

而Kafka、RabbitMQ、ActiveMQ 等支持分布式的消息队列，它们可以在多个节点之间共享数据，支持水平扩展。多个消费者可以一起来消费这些消息。

### 2. 无持久化支持

`BlockingQueue` 中的数据存储在内存中，一旦应用系统崩溃或重启，队列中的数据将会丢失。

而消息中间件都是带有持久化功能的，这些系统可以将消息存储在磁盘上，确保在系统故障时数据不会丢失。

### 3. 无高级特性支持

`BlockingQueue` 不支持消息确认、重试、死信队列、延迟消息、事务消息等高级消息队列功能。

而专业的MQ都提供了这些功能。

### 4. 缺乏管理和监控工具

`BlockingQueue` 没有内置的管理和监控工具，无法方便地监控队列的状态、消息的积压情况等。

而像Kafka、RocketMQ等，他们都带有管理和监控工具，提供了完整的管理和监控界面，可以方便地管理和监控消息队列。比如一些消息的轨迹查看，消费情况查看，重新发送等等。

### 5. 性能和吞吐量限制

`BlockingQueue` 适用于单机环境，处理大量消息时性能可能不足，无法满足高吞吐量的需求。

而高性能的分布式消息队列（如 Kafka），这些系统专门为高吞吐量设计，能够处理海量消息。