### 重复消费的常见原因

在分析解决方案前，先明确重复消费的根源：



1. **生产者重试**：生产者发送消息后未收到确认，触发重试（如网络波动）。
2. **消费者确认延迟**：消费者处理完消息后，未及时向 MQ 返回确认（ACK），MQ 认为消费失败并重新投递。
3. **MQ 集群故障**：消息中间件集群数据同步异常，导致消息被重复存储和投递。

### 确保不重复消费的核心方案

解决重复消费的关键是 **“消费逻辑幂等 + 消息唯一标识 + 确认机制”**，具体实现可从以下层面展开：

#### 1. 消息唯一标识：给消息分配全局唯一 ID

每条消息在生产时生成一个**全局唯一 ID**（如 UUID、雪花 ID 等），作为去重的依据。消费者通过判断该 ID 是否已处理过，决定是否执行消费逻辑。



**实现方式**：



- 生产者在消息体中嵌入唯一 ID（如`messageId`）。
- 消费者端维护一个 “已处理消息 ID” 的存储（如 Redis、数据库、本地缓存），处理消息前先校验该 ID 是否存在：
    - 若存在：说明已处理过，直接跳过。
    - 若不存在：执行消费逻辑，处理完成后将 ID 存入存储。

#### 2. 消费者实现幂等逻辑：业务层面保证重复处理无副作用

即使消息重复，消费逻辑本身需确保结果一致。常见手段包括：

##### （1）基于数据库唯一约束

利用数据库的**唯一索引**或**主键约束**，避免重复写入。
例如：订单支付消息，用`订单ID`作为唯一键，消费时执行`INSERT INTO pay_records (order_id, ...)`，若重复插入会触发主键冲突，直接忽略即可。

##### （2）基于乐观锁

通过版本号控制更新，确保重复操作无效。
例如：更新库存时，SQL 语句携带版本号：



sql











```sql
UPDATE inventory SET count = count - 1, version = version + 1 
WHERE product_id = 123 AND version = 5;
```



若重复执行，版本号不匹配，更新会失败（影响行数为 0），避免超卖。

##### （3）基于状态机

业务流程设计为 “状态不可逆”，重复处理时通过状态判断跳过。
例如：订单状态从 “待支付”→“已支付”→“已发货”，若收到重复的 “支付成功” 消息，检查订单状态已为 “已支付”，则直接返回成功。

#### 3. 消息队列的机制配合

消息队列本身的配置可减少重复投递的概率（但无法完全避免，需配合消费端幂等）：

##### （1）严格的消息确认机制

- 关闭 “自动确认”，开启 “手动确认”（如 RabbitMQ 的`basicAck`、Kafka 的`commitOffset`）。
- 消费者**处理完成后再发送确认**，避免 “消息接收后未处理就确认” 导致的重复投递（如进程崩溃）。

##### （2）控制重试策略

- 限制消息重试次数（如设置最大重试次数`maxRetries`），避免无限重复投递。
- 对重试失败的消息放入 “死信队列”，人工介入处理，减少无效重复。

##### （3）消息持久化与幂等存储

- 确保消息在 MQ 中持久化（如 Kafka 的`acks=all`、RabbitMQ 的持久化队列 + 持久化消息），避免 MQ 崩溃后消息丢失导致的生产者重试。
- 部分 MQ 支持 “幂等发送”（如 RocketMQ 的`producer.setRetryTimesWhenSendFailed(0)`+ 业务唯一键），但需结合业务场景。

#### 4. 分布式场景下的去重存储

在分布式系统中，消费者可能部署多实例，需用**分布式存储**记录已处理消息 ID：



- **Redis**：用`SET`存储消息 ID，设置合理过期时间（避免内存溢出），判断`EXISTS messageId`即可。
- **数据库**：建一张`processed_messages`表，`messageId`为主键，插入时若冲突则跳过。

### 总结

确保消息不重复消费的核心逻辑是：
**“消息唯一标识 + 消费端幂等处理”**，配合消息队列的手动确认机制减少重复投递。



- 消息唯一标识：用于判断是否重复。
- 消费端幂等：确保重复处理无副作用（核心）。
- MQ 机制：减少重复触发的概率，但无法替代幂等性。