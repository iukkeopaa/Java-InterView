## drop、delete 与 truncate 区别

### 1. 操作对象与作用

- **`DELETE`**：属于 **DML（数据操纵语言）**，用于删除表中**部分或全部行**（可通过 `WHERE` 条件指定删除范围），**不影响表结构**（表依然存在，索引、约束、字段等保留）。
  例：`DELETE FROM students WHERE age < 18;`（仅删除年龄小于 18 的学生）。
- **`TRUNCATE`**：属于 **DDL（数据定义语言）**，用于**清空表中所有数据**（无法通过 `WHERE` 条件筛选，只能删除全表数据），但**保留表结构**（字段、索引、约束等依然存在）。
  例：`TRUNCATE TABLE students;`（删除 `students` 表中所有数据，但表本身还在）。
- **`DROP`**：属于 **DDL（数据定义语言）**，用于**删除整个表**（包括表结构、所有数据、索引、约束等），表会从数据库中彻底消失。
  例：`DROP TABLE students;`（`students` 表不再存在）。

### 2. 事务与回滚

- **`DELETE`**：是 DML 操作，会被事务管理，**支持回滚**（若未提交事务，可通过 `ROLLBACK` 恢复删除的数据）。
  例：开启事务后执行 `DELETE`，未 `COMMIT` 前可回滚。
- **`TRUNCATE`**：是 DDL 操作，执行后会**自动提交事务**，**不支持回滚**（删除后无法恢复数据）。
- **`DROP`**：是 DDL 操作，执行后**自动提交事务**，**不支持回滚**（表删除后无法恢复，需通过备份重建）。

### 3. 执行速度

- **`TRUNCATE`**：速度最快。因为它不记录每行数据的删除日志，仅通过重建表结构（逻辑上）清空数据（比 `DROP + CREATE` 更高效）。
- **`DELETE`**：速度较慢。因为会逐行删除数据并记录详细日志（用于回滚），数据量越大，速度越慢。
- **`DROP`**：速度快（删除表结构），但与 `TRUNCATE` 场景不同（`DROP` 是删除表，`TRUNCATE` 是清空数据）。

### 4. 对自增列的影响

- **`DELETE`**：不会重置自增列（如 MySQL 的 `AUTO_INCREMENT`）。例如，表中自增 ID 最大为 100，`DELETE` 后插入新数据，ID 会从 101 开始。
- **`TRUNCATE`**：会重置自增列。清空表后插入新数据，ID 会从初始值（通常是 1）开始。
- **`DROP`**：删除表后，自增列随表结构一起消失（若重建表，自增列需重新定义）。

### 5. 适用场景

- **`DELETE`**：需删除部分数据（带 `WHERE` 条件），或需支持回滚时使用。
- **`TRUNCATE`**：需清空全表数据（无需保留部分记录），且追求效率、不担心回滚时使用（如测试环境清空数据）。
- **`DROP`**：需彻底删除表（包括结构）时使用（如废弃的表）。

### 总结对比表

| 特性             | `DELETE`            | `TRUNCATE`       | `DROP`                |
| ---------------- | ------------------- | ---------------- | --------------------- |
| 操作对象         | 表中部分 / 全部数据 | 表中全部数据     | 整个表（结构 + 数据） |
| 是否支持 `WHERE` | 是                  | 否               | 否                    |
| 事务回滚         | 可回滚（DML）       | 不可回滚（DDL）  | 不可回滚（DDL）       |
| 自增列重置       | 不重置              | 重置             | 随表删除              |
| 日志记录         | 记录每行日志        | 不记录详细日志   | 记录表删除日志        |
| 速度             | 慢（逐行删除）      | 快（重建表逻辑） | 快（删除表结构）      |
| 对表结构影响     | 无（保留结构）      | 无（保留结构）   | 删除表结构            |

## 数据库设计通常分为哪几步

### 1. **需求分析（基础阶段）**

**目的**：明确数据库需要解决的业务问题，收集并梳理所有需求。
**核心工作**：



- 与业务方（用户、产品、运营等）沟通，明确**数据需求**（需要存储哪些数据，如用户信息、订单信息）、**处理需求**（需要支持哪些操作，如查询、新增、统计）、**约束条件**（如数据格式、业务规则、性能要求）。
- 输出《需求规格说明书》，包含：
    - 实体清单（如 “用户”“商品”“订单”）；
    - 实体属性（如用户的 “ID”“姓名”“手机号”）；
    - 业务流程（如 “下单 - 支付 - 发货” 的数据流）；
    - 性能指标（如并发量、查询响应时间）。



**关键**：需求分析是后续所有设计的基础，务必全面、准确，避免遗漏核心业务场景。

### 2. **概念结构设计（抽象阶段）**

**目的**：将需求转化为**独立于具体数据库系统**的抽象概念模型（不涉及具体表结构或数据库类型）。
**核心工作**：



- 基于需求分析，提炼**实体（Entity）**（如 “用户”“订单”）、**属性（Attribute）**（实体的特征，如订单的 “订单号”“金额”）、**实体间的联系（Relationship）**（如 “用户 - 订单” 是 “一对多” 联系：一个用户可创建多个订单）。
- 用**E-R 图（实体 - 关系图）** 可视化概念模型，清晰展示实体、属性、联系（如 1:1、1:n、m:n）。



**示例**：



- 实体 “学生” 属性：学号、姓名、专业；
- 实体 “课程” 属性：课程号、课程名、学分；
- 联系 “选课”：学生与课程是 m:n 联系（一个学生可选多门课，一门课可被多个学生选），联系属性为 “成绩”。



**关键**：概念模型需简洁、抽象，不依赖具体数据库（如 MySQL、Oracle），聚焦业务本质。

### 3. **逻辑结构设计（转化阶段）**

**目的**：将概念模型（E-R 图）转化为**具体数据库系统支持的逻辑模型**（如关系模型中的表结构），并优化结构。
**核心工作**：



- 模型转化

  ：将 E-R 图中的实体、联系转化为关系表：

    - 实体→表（实体名→表名，属性→列名）；
    - 1:1 联系→可合并到任意一方表中（如 “用户” 与 “用户详情” 是 1:1，可将详情属性合并到 “用户表”）；
    - 1:n 联系→在 “多” 的一方表中添加 “一” 方的主键作为外键（如 “订单表” 添加 “用户 ID” 关联 “用户表”）；
    - m:n 联系→新增中间表（如 “学生 - 课程” 的 m:n 联系，新增 “选课表”，含 “学号”“课程号”“成绩”）。

- **规范化处理**：通过**范式（Normal Form）** 优化表结构，减少数据冗余和操作异常（如 1NF 确保列不可再分，2NF 消除部分依赖，3NF 消除传递依赖）。

- 确定数据类型、约束（主键、外键、非空、唯一、默认值等）。



**输出**：逻辑模型（表结构设计表），含表名、列名、数据类型、约束、主键、外键等。

### 4. **物理结构设计（落地阶段）**

**目的**：根据逻辑模型，结合具体数据库系统（如 MySQL、PostgreSQL），设计**物理存储结构**，优化性能。
**核心工作**：



- **选择存储引擎**：如 MySQL 中，InnoDB 支持事务和外键，适合核心业务表；MyISAM 查询快但不支持事务，适合只读表（如日志表）。
- **设计索引**：为高频查询字段（如订单号、用户 ID）创建索引，提升查询效率；避免过度索引（影响写入性能）。
- **确定存储细节**：表空间分配、数据文件路径、分区策略（如大表按时间分区）、缓存设置等。
- **性能优化**：如分表分库（应对海量数据）、字段长度优化（如手机号用 CHAR (11) 而非 VARCHAR）。



**关键**：物理设计需结合具体数据库特性和业务性能需求，平衡读写效率。

### 5. **数据库实施（开发阶段）**

**目的**：将设计落地为实际可运行的数据库。
**核心工作**：



- 编写 SQL 脚本，创建数据库、表、索引、视图、存储过程等（如`CREATE DATABASE`、`CREATE TABLE`）。
- 导入测试数据，验证表结构、约束、关联关系是否符合设计（如外键是否生效、索引是否提升查询速度）。
- 进行功能测试（如新增 / 查询数据是否正常）、性能测试（如并发写入是否卡顿），修复设计缺陷。

### 6. **运行与维护（迭代阶段）**

**目的**：保障数据库长期稳定运行，并根据业务变化持续优化。
**核心工作**：



- **日常维护**：监控数据库性能（如 CPU、内存、磁盘占用）、备份数据（定时全量 + 增量备份）、处理故障（如死锁、数据损坏）。
- **优化迭代**：根据业务增长（如数据量激增）或需求变化（如新增字段、表），调整结构（如新增索引、分表）、重构表（如拆分大表）。
- **安全管理**：权限控制（如只读用户、读写用户）、防注入、数据加密等。

## UTF-8 使用

UTF-8 是目前最常用的 Unicode 字符编码方式，它通过可变长度字节（1-4 字节）表示 Unicode 字符集中的字符，兼容 ASCII 编码（1 字节部分与 ASCII 完全一致），且支持全球几乎所有语言（包括中文、英文、日文、符号等），因此被广泛用于各类场景。

UTF-8 使用 1 到 4 个字节为每个字符编码， UTF-16 使用 2 或 4 个字节为每个字符编码，UTF-32 固定位 4 个字节为每个字符编码。UTF-8 可以根据不同的符号自动选择编码的长短，像英文字符只需要 1 个字节就够了，这一点 ASCII 字符集一样 。因此，对于英语字符，UTF-8 编码和 ASCII 码是相同的。UTF-32 的规则最简单，不过缺陷也比较明显，对于英文字母这类字符消耗的空间是 UTF-8 的 4 倍之多

**注意**

MySQL 中的 utf8 实际是 utf8mb3，仅支持 3 字节字符（不支持 emoji），需用 utf8mb4（真正的 UTF-8，支持 4 字节）：